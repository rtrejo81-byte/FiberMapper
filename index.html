<!DOCTYPE html> 
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Fiber Mapper - Sistema de Mapeo FTTX</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

  <style>
    :root {
      --primary: #1e40af;
      --primary-dark: #1e3a8a;
      --secondary: #3b82f6;
      --accent: #f59e0b;
      --background: #0f172a;
      --surface: #1e293b;
      --surface-light: #334155;
      --text: #f8fafc;
      --text-secondary: #cbd5e1;
      --error: #ef4444;
      --success: #10b981;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background-color: var(--background);
      color: var(--text);
      overflow: hidden;
    }

    .app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .header {
      background: linear-gradient(90deg, var(--primary-dark) 0%, var(--background) 100%);
      padding: 10px 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 2px solid var(--surface-light);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      gap: 10px;
    }

    .logo-container {
      display: flex;
      align-items: center;
      gap: 12px;
      min-width: 0;
    }

    .logo {
      font-size: 24px;
      color: var(--secondary);
      flex: 0 0 auto;
    }

    .brand-wrap {
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    .app-name {
      font-size: 18px;
      font-weight: 700;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1.1;
    }

    .app-subtitle {
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1;
    }

    .header-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
      flex: 1 1 auto;
    }

    .map-type-selector {
      display: flex;
      background-color: var(--surface);
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid var(--surface-light);
    }

    .map-type-btn {
      padding: 6px 10px;
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s;
      font-size: 13px;
    }

    .map-type-btn.active {
      background-color: var(--secondary);
      color: white;
    }

    select,
    button,
    .file-upload-label {
      background-color: var(--surface);
      color: var(--text);
      border: 1px solid var(--surface-light);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      line-height: 1.2;
    }

    select:hover,
    button:hover,
    .file-upload-label:hover {
      background-color: var(--surface-light);
    }

    .file-upload-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .file-upload-label input {
      display: none;
    }

    .hamburger {
      display: none;
      background: var(--surface);
      border: 1px solid var(--surface-light);
      border-radius: 8px;
      padding: 6px 10px;
      align-items: center;
      gap: 8px;
    }

    .main-content {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .map-container {
      flex: 1;
      position: relative;
      min-width: 0;
      transition: all 0.3s ease;
    }

    .map-container.expanded {
      flex: 1 0 100%;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .map-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: rgba(30, 41, 59, 0.8);
      padding: 8px;
      border-radius: 10px;
      backdrop-filter: blur(4px);
      max-width: 46vw;
    }

    .map-control-btn {
      background-color: var(--surface-light);
      border: 1px solid #475569;
      color: var(--text);
      border-radius: 8px;
      padding: 6px 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s;
      font-size: 13px;
    }

    .map-control-btn:hover {
      background-color: #475569;
    }

    .map-control-btn.active {
      background-color: var(--success);
      color: white;
    }

    .sidebar {
      width: 380px;
      background-color: var(--surface);
      border-left: 1px solid var(--surface-light);
      padding: 16px;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      transition: all 0.3s ease;
    }

    .sidebar.hidden {
      width: 0;
      padding: 0;
      border-left: none;
      overflow: hidden;
    }

    .sidebar-toggle {
      position: absolute;
      top: 50%;
      left: -15px;
      transform: translateY(-50%);
      width: 30px;
      height: 60px;
      background-color: var(--surface);
      border: 1px solid var(--surface-light);
      border-right: none;
      border-radius: 8px 0 0 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      color: var(--text);
      transition: all 0.3s ease;
    }

    .sidebar-toggle:hover {
      background-color: var(--surface-light);
    }

    .sidebar-section {
      margin-bottom: 18px;
    }

    .sidebar-title {
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--surface-light);
    }

    .assets-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 200px;
      overflow-y: auto;
      padding-right: 5px;
    }

    .asset-item {
      background-color: var(--surface-light);
      border-radius: 10px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .asset-item:hover {
      background-color: #475569;
    }

    .asset-item.selected {
      border: 2px solid var(--secondary);
    }

    .asset-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      gap: 6px;
    }

    .asset-name {
      font-weight: 700;
      font-size: 14px;
    }

    .asset-type {
      font-size: 11px;
      background-color: var(--primary);
      padding: 2px 8px;
      border-radius: 10px;
      white-space: nowrap;
    }

    .asset-coords {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .stats-container {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    .stat-box {
      flex: 1;
      background-color: var(--surface-light);
      padding: 10px;
      border-radius: 10px;
      text-align: center;
    }

    .stat-value {
      font-size: 18px;
      font-weight: 800;
      color: var(--secondary);
    }

    .stat-label {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .search-box {
      margin-bottom: 12px;
    }

    .search-box input {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      background-color: var(--surface-light);
      color: var(--text);
      border: 1px solid #475569;
    }

    .cable-options {
      display: flex;
      gap: 8px;
      margin-top: 6px;
    }

    .cable-option {
      flex: 1;
      padding: 8px;
      text-align: center;
      border-radius: 8px;
      background-color: var(--surface-light);
      cursor: pointer;
      transition: all 0.2s;
      user-select: none;
    }

    .cable-option.selected {
      background-color: var(--secondary);
      color: white;
    }

    .distance-display {
      background-color: var(--surface-light);
      padding: 10px;
      border-radius: 8px;
      margin-top: 10px;
      text-align: center;
      font-weight: bold;
      color: var(--secondary);
    }

    .cable-totals {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    .cable-total {
      flex: 1;
      background-color: var(--surface-light);
      padding: 10px;
      border-radius: 8px;
      text-align: center;
    }

    .cable-total.fo {
      border-left: 4px solid #3b82f6;
    }

    .cable-total.drop {
      border-left: 4px solid #f59e0b;
    }

    .cable-total-value {
      font-size: 16px;
      font-weight: bold;
    }

    .cable-total-label {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .cable-segments {
      margin-top: 10px;
      max-height: 150px;
      overflow-y: auto;
    }

    .cable-segment {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
      border-bottom: 1px solid var(--surface-light);
      font-size: 13px;
    }

    .cable-segment:last-child {
      border-bottom: none;
    }

    .manual-coords {
      background-color: var(--surface-light);
      padding: 12px;
      border-radius: 10px;
      margin-top: 12px;
    }

    .manual-coords-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      align-items: center;
    }

    .manual-coords-btn {
      grid-column: 1 / span 2;
      background-color: var(--secondary);
      color: white;
      border: none;
      padding: 8px;
      border-radius: 8px;
      cursor: pointer;
      text-align: center;
    }

    .clear-screen-btn {
      background-color: var(--error);
      color: white;
      border: none;
      padding: 10px;
      border-radius: 10px;
      margin-top: 12px;
      cursor: pointer;
      transition: all 0.2s;
      width: 100%;
      text-align: center;
    }

    .clear-screen-btn:hover {
      opacity: 0.9;
    }

    /* Popups del mapa */
    .popup-content {
      font-size: 12px;
    }
    .popup-title {
      font-weight: 800;
      margin-bottom: 4px;
    }
    .popup-coords {
      color: #94a3b8;
      margin-bottom: 6px;
    }
    .popup-actions {
      display: flex;
      gap: 6px;
    }
    .popup-btn {
      background: var(--secondary);
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 12px;
    }

    /* Etiquetas en el mapa */
    .map-label {
      background-color: rgba(30, 41, 59, 0.8);
      border: 1px solid #475569;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 12px;
      font-weight: bold;
      white-space: nowrap;
      pointer-events: none;
      backdrop-filter: blur(2px);
      color: #fff;
    }

    /* Etiquetas de distancia */
    .distance-label {
      background-color: rgba(59, 130, 246, 0.85);
      color: white;
      border: 1px solid #3b82f6;
      border-radius: 4px;
      padding: 1px 6px;
      font-size: 11px;
      font-weight: bold;
      pointer-events: none;
      backdrop-filter: blur(2px);
    }

    /* Modal de exportación */
    .export-modal,
    .gps-modal,
    .photo-modal {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }
    .export-content,
    .gps-content,
    .photo-content {
      background-color: var(--surface);
      padding: 16px;
      border-radius: 12px;
      width: 92%;
      max-width: 420px;
      border: 1px solid var(--surface-light);
    }
    .export-options {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin: 12px 0;
    }
    .export-option,
    .share-option {
      padding: 10px;
      background-color: var(--surface-light);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }
    .export-option:hover,
    .share-option:hover {
      background-color: var(--secondary);
    }

    /* Modal GPS form */
    .gps-form {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .gps-row {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 8px;
      align-items: center;
    }
    .gps-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 4px;
    }
    .btn-primary {
      background: var(--success);
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
    }
    .btn-outline {
      background: var(--surface-light);
      color: #fff;
      border: 1px solid #475569;
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
    }

    /* Modal para fotos */
    .photo-preview {
      max-width: 100%;
      max-height: 200px;
      border-radius: 8px;
      margin: 10px 0;
      display: none;
    }
    .photo-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 10px;
    }

    .hint {
      background-color: var(--primary);
      padding: 12px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.5;
      margin-top: 12px;
    }

    .copyright {
      text-align: center;
      margin-top: auto;
      padding-top: 10px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Nuevos estilos para control de cables */
    .cable-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 10px;
    }

    .cable-control-btn {
      padding: 8px;
      text-align: center;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 13px;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }

    .cable-control-btn.undo {
      background-color: var(--accent);
      color: white;
    }

    .cable-control-btn.cancel {
      background-color: var(--error);
      color: white;
    }
    
    .cable-control-btn.finish {
      background-color: var(--success);
      color: white;
      grid-column: span 2;
    }

    .cable-control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .drawing-status {
      background-color: var(--primary);
      color: white;
      padding: 8px;
      border-radius: 8px;
      text-align: center;
      margin-top: 10px;
      font-size: 13px;
      display: none;
    }

    /* Puntero estático en el centro del mapa */
    .static-crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 40px;
      height: 40px;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 1000;
      display: none;
    }

    .static-crosshair::before,
    .static-crosshair::after {
      content: '';
      position: absolute;
      background-color: #ff0000;
    }

    .static-crosshair::before {
      width: 2px;
      height: 40px;
      left: 19px;
      top: 0;
    }

    .static-crosshair::after {
      width: 40px;
      height: 2px;
      left: 0;
      top: 19px;
    }

    .static-crosshair .center-dot {
      position: absolute;
      width: 6px;
      height: 6px;
      background-color: #ff0000;
      border-radius: 50%;
      top: 17px;
      left: 17px;
    }

    /* Botón para agregar en posición del puntero */
    .add-at-pointer-btn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background-color: var(--success);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 15px;
      cursor: pointer;
      display: none;
      align-items: center;
      gap: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    /* Opciones de tipo de instalación de cable */
    .cable-installation-options {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    .cable-installation-option {
      flex: 1;
      padding: 8px;
      text-align: center;
      border-radius: 8px;
      background-color: var(--surface-light);
      cursor: pointer;
      transition: all 0.2s;
      user-select: none;
    }

    .cable-installation-option.selected {
      background-color: var(--secondary);
      color: white;
    }

    /* Nuevos estilos para polígonos */
    .polygon-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 10px;
    }

    .polygon-control-btn {
      padding: 8px;
      text-align: center;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 13px;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }

    .polygon-control-btn.undo {
      background-color: var(--accent);
      color: white;
    }

    .polygon-control-btn.cancel {
      background-color: var(--error);
      color: white;
    }
    
    .polygon-control-btn.finish {
      background-color: var(--success);
      color: white;
      grid-column: span 2;
    }

    .polygon-control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .polygon-drawing-status {
      background-color: var(--primary);
      color: white;
      padding: 8px;
      border-radius: 8px;
      text-align: center;
      margin-top: 10px;
      font-size: 13px;
      display: none;
    }

    .polygon-area-display {
      background-color: var(--surface-light);
      padding: 10px;
      border-radius: 8px;
      margin-top: 10px;
      text-align: center;
      font-weight: bold;
      color: var(--secondary);
    }

    /* Paleta de colores para polígonos */
    .color-palette {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 6px;
      margin-top: 10px;
    }

    .color-option {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
    }

    .color-option.selected {
      border-color: white;
      transform: scale(1.1);
    }

    /* Controles de visibilidad de activos */
    .visibility-controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 10px;
    }

    .visibility-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      background-color: var(--surface-light);
      border-radius: 8px;
    }

    .visibility-label {
      font-size: 13px;
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #475569;
      transition: .4s;
      border-radius: 20px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: var(--success);
    }

    input:checked + .slider:before {
      transform: translateX(20px);
    }

    /* Estilos para la edición de polígonos */
    .polygon-edit-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 10px;
    }

    .polygon-edit-btn {
      padding: 8px;
      text-align: center;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 13px;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }

    .polygon-edit-btn.edit {
      background-color: var(--accent);
      color: white;
    }

    .polygon-edit-btn.save {
      background-color: var(--success);
      color: white;
      grid-column: span 2;
    }

    .polygon-edit-btn.cancel {
      background-color: var(--error);
      color: white;
    }

    .vertex-marker {
      background-color: #ff0000;
      border: 2px solid white;
      border-radius: 50%;
      width: 12px;
      height: 12px;
      cursor: move;
    }

    .midpoint-marker {
      background-color: #00ff00;
      border: 2px solid white;
      border-radius: 50%;
      width: 8px;
      height: 8px;
      cursor: pointer;
    }

    /* Responsive */
    @media (max-width: 992px) {
      .main-content {
        flex-direction: column;
      }
      .sidebar {
        width: 100%;
        height: 40%;
        border-left: none;
        border-top: 1px solid var(--surface-light);
      }
      .hamburger {
        display: inline-flex;
      }
      .header {
        flex-wrap: wrap;
        gap: 8px;
      }
      .header-controls {
        justify-content: center;
      }
      /* Controles del mapa más compactos en móvil */
      .map-controls {
        top: 8px;
        right: 8px;
        padding: 6px;
        gap: 6px;
        max-width: 70vw;
      }
      .map-control-btn span {
        display: none; /* Sólo iconos en móvil para ahorrar espacio */
      }
      .add-at-pointer-btn {
        bottom: 10px;
        padding: 8px 12px;
        font-size: 12px;
      }
      .sidebar-toggle {
        display: none;
      }
    }

    @media (max-width: 420px) {
      .app-name {
        font-size: 16px;
      }
      .app-subtitle {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <header class="header">
      <button id="toggle-sidebar" class="hamburger" title="Mostrar/ocultar panel">
        <i class="fas fa-bars"></i><span> Menú</span>
      </button>

      <div class="logo-container">
        <div class="logo">
          <i class="fas fa-map-marked-alt"></i>
        </div>
        <div class="brand-wrap">
          <h1 class="app-name">Fiber Mapper</h1>
          <div class="app-subtitle">Sistema de Mapeo de Infraestructura FTTX</div>
        </div>
      </div>

      <div class="header-controls">
        <div class="map-type-selector">
          <button class="map-type-btn active" id="standard-map-btn">
            <i class="fas fa-map"></i> <span>Estándar</span>
          </button>
          <button class="map-type-btn" id="satellite-map-btn">
            <i class="fas fa-satellite"></i> <span>Satélite</span>
          </button>
          <button class="map-type-btn" id="googleearth-map-btn">
            <i class="fas fa-globe-americas"></i> <span>Google Earth</span>
          </button>
        </div>

        <select id="asset-type-selector" title="Tipo de activo para clic en mapa">
          <option value="poste">POSTE</option>
          <option value="nap">NAP</option>
          <option value="cab">Cable FO</option>
          <option value="fat">NAP DES</option>
          <option value="olt">OLT</option>
          <option value="fdh">FDH</option>
          <option value="emp">EMP</option>
          <option value="pzo">POZO</option>
          <option value="ont">ONT</option>
          <option value="odf">ODF</option>
          <option value="box">FDH BOX</option>
          <option value="polygon">POLÍGONO</option>
          <option value="homepassed">HOME PASSED</option>
        </select>

        <button id="add-gps-btn" title="Agregar activo con GPS">
          <i class="fas fa-crosshairs"></i> Agregar con GPS
        </button>

        <button id="export-data" title="Exportar CSV/KML">
          <i class="fas fa-download"></i> Exportar
        </button>

        <label class="file-upload-label" title="Importar CSV/KML">
          <i class="fas fa-upload"></i> Importar
          <input type="file" id="import-data" accept=".csv,.kml" />
        </label>

        <button id="clear-screen" title="Limpiar todo">
          <i class="fas fa-trash"></i> Limpiar
        </button>
      </div>
    </header>

    <div class="main-content">
      <div class="map-container" id="map-container">
        <div id="map"></div>
        
        <!-- Puntero estático en el centro -->
        <div class="static-crosshair" id="static-crosshair">
          <div class="center-dot"></div>
        </div>

        <!-- Botón para agregar en posición del puntero -->
        <button class="add-at-pointer-btn" id="add-at-pointer-btn">
          <i class="fas fa-plus-circle"></i> Agregar aquí
        </button>

        <div class="map-controls" id="map-controls">
          <button class="map-control-btn" id="locate-me-btn" title="Centrar en mi ubicación">
            <i class="fas fa-location-arrow"></i><span> Mi ubicación</span>
          </button>
          <button class="map-control-btn" id="zoom-in-btn" title="Acercar">
            <i class="fas fa-plus"></i><span> Acercar</span>
          </button>
          <button class="map-control-btn" id="zoom-out-btn" title="Alejar">
            <i class="fas fa-minus"></i><span> Alejar</span>
          </button>
          <button class="map-control-btn" id="toggle-labels-btn" title="Mostrar/ocultar etiquetas">
            <i class="fas fa-tags"></i><span> Etiquetas</span>
          </button>
        </div>
      </div>

      <aside class="sidebar" id="sidebar">
        <div class="sidebar-toggle" id="sidebar-toggle" title="Expandir/contraer panel">
          <i class="fas fa-chevron-left" id="toggle-icon"></i>
        </div>
        
        <!-- Estadísticas -->
        <div class="sidebar-section">
          <div class="sidebar-title">Estadísticas</div>
          <div class="stats-container">
            <div class="stat-box">
              <div class="stat-value" id="stat-assets">0</div>
              <div class="stat-label">Activos</div>
            </div>
            <div class="stat-box">
              <div class="stat-value" id="stat-cables">0</div>
              <div class="stat-label">Cables</div>
            </div>
            <div class="stat-box">
              <div class="stat-value" id="stat-distance">0 m</div>
              <div class="stat-label">Distancia FO</div>
            </div>
          </div>
        </div>

        <!-- Control de visibilidad -->
        <div class="sidebar-section">
          <div class="sidebar-title">Visibilidad</div>
          <div class="visibility-controls" id="visibility-controls">
            <!-- Los controles de visibilidad se generarán dinámicamente -->
          </div>
        </div>

        <!-- Buscar -->
        <div class="sidebar-section">
          <div class="sidebar-title">Buscar</div>
          <div class="search-box">
            <input id="search-input" type="text" placeholder="Buscar por etiqueta..." />
          </div>
        </div>

        <!-- Lista de activos -->
        <div class="sidebar-section">
          <div class="sidebar-title">Activos</div>
          <div id="assets-list" class="assets-list"></div>
        </div>

        <!-- Cable -->
        <div class="sidebar-section">
          <div class="sidebar-title">Cable</div>
          <div class="cable-options">
            <div class="cable-option selected" data-type="fo">FO</div>
            <div class="cable-option" data-type="drop">DROP</div>
          </div>

          <!-- Opciones de tipo de instalación -->
          <div class="cable-installation-options">
            <div class="cable-installation-option selected" data-installation="aerial">Aéreo</div>
            <div class="cable-installation-option" data-installation="duct">Ducto</div>
          </div>

          <div class="distance-display" id="cable-distance">Distancia: 0.00 metros</div>
          <div class="distance-display" id="segment-distance">Último segmento: 0.00 metros</div>

          <!-- Nuevos controles para cable -->
          <div class="cable-controls" id="cable-controls" style="display: none;">
            <button class="cable-control-btn undo" id="undo-cable-point" disabled>
              <i class="fas fa-undo"></i> Deshacer
            </button>
            <button class="cable-control-btn cancel" id="cancel-cable-drawing">
              <i class="fas fa-times"></i> Cancelar
            </button>
            <button class="cable-control-btn finish" id="finish-cable-drawing" disabled>
              <i class="fas fa-check"></i> Finalizar Cable
            </button>
          </div>

          <div class="drawing-status" id="drawing-status">
            <i class="fas fa-drawing-pin"></i> Dibujando cable - Haz clic para agregar puntos
          </div>

          <div class="cable-totals" id="cable-totals">
            <div class="cable-total fo">
              <div class="cable-total-value" id="total-fo">0 m</div>
              <div class="cable-total-label">Total FO</div>
            </div>
            <div class="cable-total drop">
              <div class="cable-total-value" id="total-drop">0 m</div>
              <div class="cable-total-label">Total DROP</div>
            </div>
          </div>

          <div id="cable-segments-container" style="display:none;">
            <div class="sidebar-title" style="margin-top:10px;">Tramos</div>
            <div class="cable-segments" id="cable-segments-list"></div>
          </div>

          <div class="manual-coords">
            <div style="font-weight:700;margin-bottom:8px;">Agregar por coordenadas</div>
            <div class="manual-coords-grid">
              <label>Latitud</label>
              <input type="number" step="0.000001" id="manual-lat" />
              <label>Longitud</label>
              <input type="number" step="0.000001" id="manual-lng" />
              <button class="manual-coords-btn" id="add-manual-point">
                Agregar punto con coords
              </button>
            </div>
          </div>
        </div>

        <!-- Polígonos -->
        <div class="sidebar-section">
          <div class="sidebar-title">Polígonos</div>
          
          <!-- Paleta de colores para polígonos -->
          <div class="color-palette" id="polygon-color-palette">
            <div class="color-option selected" style="background-color: #10b981;" data-color="#10b981"></div>
            <div class="color-option" style="background-color: #3b82f6;" data-color="#3b82f6"></div>
            <div class="color-option" style="background-color: #f59e0b;" data-color="#f59e0b"></div>
            <div class="color-option" style="background-color: #ef4444;" data-color="#ef4444"></div>
            <div class="color-option" style="background-color: #8b5cf6;" data-color="#8b5cf6"></div>
            <div class="color-option" style="background-color: #06b6d4;" data-color="#06b6d4"></div>
            <div class="color-option" style="background-color: #84cc16;" data-color="#84cc16"></div>
            <div class="color-option" style="background-color: #f97316;" data-color="#f97316"></div>
            <div class="color-option" style="background-color: #ec4899;" data-color="#ec4899"></div>
            <div class="color-option" style="background-color: #64748b;" data-color="#64748b"></div>
          </div>

          <div class="polygon-area-display" id="polygon-area">Área: 0.00 m²</div>

          <!-- Controles para polígonos -->
          <div class="polygon-controls" id="polygon-controls" style="display: none;">
            <button class="polygon-control-btn undo" id="undo-polygon-point" disabled>
              <i class="fas fa-undo"></i> Deshacer
            </button>
            <button class="polygon-control-btn cancel" id="cancel-polygon-drawing">
              <i class="fas fa-times"></i> Cancelar
            </button>
            <button class="polygon-control-btn finish" id="finish-polygon-drawing" disabled>
              <i class="fas fa-check"></i> Finalizar Polígono
            </button>
          </div>

          <div class="polygon-edit-controls" id="polygon-edit-controls" style="display: none;">
            <button class="polygon-edit-btn edit" id="add-polygon-vertex">
              <i class="fas fa-plus"></i> Agregar Vértice
            </button>
            <button class="polygon-edit-btn cancel" id="cancel-polygon-edit">
              <i class="fas fa-times"></i> Cancelar
            </button>
            <button class="polygon-edit-btn save" id="save-polygon-edit">
              <i class="fas fa-save"></i> Guardar Cambios
            </button>
          </div>

          <div class="polygon-drawing-status" id="polygon-drawing-status">
            <i class="fas fa-drawing-pin"></i> Dibujando polígono - Haz clic para agregar vértices
          </div>

          <div class="polygon-edit-status" id="polygon-edit-status" style="display: none;">
            <i class="fas fa-edit"></i> Editando polígono - Arrastra vértices o haz clic en segmentos
          </div>

          <div class="manual-coords">
            <div style="font-weight:700;margin-bottom:8px;">Agregar vértice por coordenadas</div>
            <div class="manual-coords-grid">
              <label>Latitud</label>
              <input type="number" step="0.000001" id="manual-polygon-lat" />
              <label>Longitud</label>
              <input type="number" step="0.000001" id="manual-polygon-lng" />
              <button class="manual-coords-btn" id="add-manual-polygon-point">
                Agregar vértice con coords
              </button>
            </div>
          </div>
        </div>

        <!-- Editor -->
        <div class="sidebar-section">
          <div class="sidebar-title">Editor</div>
          <div id="editor-panel">
            <div class="editor-grid">
              <span class="editor-label">ID:</span>
              <div id="editor-id" style="font-family:monospace; font-size:12px;color:#9ca3af;">—</div>

              <span class="editor-label">Etiqueta:</span>
              <input id="editor-label" />

              <span class="editor-label">Tipo:</span>
              <select id="editor-type">
                <option value="poste">POSTE</option>
                <option value="nap">NAP</option>
                <option value="cab">Cable FO</option>
                <option value="fat">NAP DES</option>
                <option value="olt">OLT</option>
                <option value="fdh">FDH</option>
                <option value="emp">EMP</option>
                <option value="pzo">POZO</option>
                <option value="ont">ONT</option>
                <option value="odf">ODF</option>
                <option value="box">FDH BOX</option>
                <option value="polygon">POLÍGONO</option>
                <option value="homepassed">HOME PASSED</option>
              </select>

              <span class="editor-label">Latitud:</span>
              <input type="number" step="0.000001" id="editor-lat" />

              <span class="editor-label">Longitud:</span>
              <input type="number" step="0.000001" id="editor-lng" />

              <span class="editor-label">Propiedades (JSON):</span>
              <textarea id="editor-props"></textarea>
            </div>
            <button class="delete-btn" id="delete-asset">
              <i class="fas fa-trash"></i> Eliminar Activo
            </button>
            <button class="popup-btn" id="add-photo-btn" style="margin-top: 10px; width: 100%;">
              <i class="fas fa-camera"></i> Agregar Foto
            </button>
          </div>
          <div id="no-selection-message">Selecciona un activo del mapa o de la lista para editarlo.</div>
        </div>

        <button class="clear-screen-btn" id="clear-sidebar-btn">
          <i class="fas fa-broom"></i> Limpiar Proyecto
        </button>

        <div class="hint">
          <i class="fas fa-lightbulb"></i> Consejo: Haz clic en el mapa para agregar un activo
          del tipo seleccionado. Para cables, haz clic en varios puntos para crear una ruta.
          Para polígonos, haz clic para agregar vértices y doble clic para finalizar.
        </div>

        <div class="copyright">
          &copy; 2025 Fiber Mapper - Todos los derechos reservados para Roberto Trejo
        </div>
      </aside>
    </div>
  </div>

  <!-- Modal de Exportación -->
  <div class="export-modal" id="export-modal">
    <div class="export-content">
      <h2>Exportar Datos</h2>
      <p>Selecciona el formato de exportación:</p>

      <div class="export-options">
        <div class="export-option" data-format="csv">
          <i class="fas fa-file-csv"></i> CSV
        </div>
        <div class="export-option" data-format="kml">
          <i class="fas fa-globe-americas"></i> KML
        </div>
      </div>

      <div id="share-options-container" style="display: none;">
        <p>¿Cómo deseas compartir?</p>
        <div class="share-options">
          <div class="share-option" data-action="save">
            <i class="fas fa-save"></i> Guardar localmente
          </div>
          <div class="share-option" data-action="email">
            <i class="fas fa-envelope"></i> Compartir por correo
          </div>
          <div class="share-option" data-action="whatsapp">
            <i class="fab fa-whatsapp"></i> Compartir por WhatsApp
          </div>
        </div>
      </div>

      <button id="close-export" style="margin-top: 14px; width: 100%;">Cancelar</button>
    </div>
  </div>

  <!-- Modal Agregar con GPS -->
  <div class="gps-modal" id="gps-modal">
    <div class="gps-content">
      <h2 style="margin-bottom:8px;">Agregar activo con GPS</h2>
      <div class="gps-form">
        <div class="gps-row">
          <label>Tipo</label>
          <select id="gps-type">
            <option value="poste">POSTE</option>
            <option value="nap">NAP</option>
            <option value="fat">NAP DES</option>
            <option value="olt">OLT</option>
            <option value="fdh">FDH</option>
            <option value="emp">EMP</option>
            <option value="pzo">POZO</option>
            <option value="ont">ONT</option>
            <option value="odf">ODF</option>
            <option value="box">FDH BOX</option>
            <option value="polygon">POLÍGONO</option>
            <option value="homepassed">HOME PASSED</option>
          </select>
        </div>
        <div class="gps-row">
          <label>Etiqueta</label>
          <input id="gps-label" placeholder="Ej: NAP_001 o dejar vacío" />
        </div>
        <div class="gps-row">
          <label>Precisión</label>
          <select id="gps-accuracy">
            <option value="true">Alta (más lento)</option>
            <option value="false" selected>Normal</option>
          </select>
        </div>
        <div id="gps-status" style="font-size:12px;color:#93c5fd;min-height:18px;"></div>
        <div class="gps-actions">
          <button class="btn-outline" id="gps-cancel">Cancelar</button>
          <button class="btn-primary" id="gps-confirm">Obtener ubicación</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal para agregar foto -->
  <div class="photo-modal" id="photo-modal">
    <div class="photo-content">
      <h2 style="margin-bottom:8px;">Agregar foto al activo</h2>
      <div id="photo-preview-container" style="text-align: center;">
        <img id="photo-preview" class="photo-preview" alt="Vista previa">
      </div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
        <label for="camera-input" class="file-upload-label">
          <i class="fas fa-camera"></i> Cámara
          <input type="file" id="camera-input" accept="image/*" capture="environment">
        </label>
        <label for="gallery-input" class="file-upload-label">
          <i class="fas fa-image"></i> Galería
          <input type="file" id="gallery-input" accept="image/*">
        </label>
      </div>
      <div class="photo-actions">
        <button class="btn-outline" id="photo-cancel">Cancelar</button>
        <button class="btn-primary" id="photo-confirm">Guardar</button>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // Estado de la aplicación
    // =========================
    let assets = [];
    let selectedAssetId = null;
    let map;
    let markers = {};
    let polylines = {};
    let polygons = {};
    let labelLayers = {};
    let distanceLabels = [];
    let showLabels = true;

    let currentMapType = "standard";
    let standardTileLayer, satelliteTileLayer, googleEarthTileLayer;

    let currentCableType = "fo";
    let currentCableInstallation = "aerial";
    let cablePoints = [];
    let drawingCable = false;
    let tempMarkers = [];
    let tempPolylines = [];

    // Nuevas variables para polígonos
    let polygonPoints = [];
    let drawingPolygon = false;
    let tempPolygonMarkers = [];
    let tempPolygonLines = [];
    let tempPolygon = null;
    let currentPolygonColor = "#10b981";

    let selectedExportFormat = null;

    // Variables para el NAP
    let currentNapData = null;
    let napPhotoData = null;

    // Nuevas variables para control de ubicación
    let currentLocationMarker = null;
    let currentAccuracyCircle = null;
    let locationWatchId = null;
    let isTrackingLocation = false;

    // Variables para el puntero de precisión y fotos
    let currentPhotoData = null;
    let currentAssetForPhoto = null;

    // Variable para controlar la visibilidad del puntero estático
    let staticCrosshairVisible = false;

    // Variable para controlar el estado del panel lateral
    let sidebarExpanded = true;

    // Variables para edición de polígonos
    let editingPolygon = false;
    let currentEditingPolygonId = null;
    let vertexMarkers = [];
    let midpointMarkers = [];
    let originalPolygonPoints = [];

    // Controles de visibilidad
    let assetVisibility = {
      poste: true,
      nap: true,
      cab: true,
      fat: true,
      olt: true,
      fdh: true,
      emp: true,
      pzo: true,
      ont: true,
      odf: true,
      box: true,
      polygon: true,
      homepassed: true,
    };

    // Contadores para numeración automática
    const assetCounters = {
        poste: 0,
        nap: 0,
        fat: 0,
        olt: 0,
        fdh: 0,
        emp: 0,
        pzo: 0,
        ont: 0,
        odf: 0,
        box: 0,
        polygon: 0,
        homepassed: 0,
    };

    // Íconos personalizados por tipo
    const ICONS = {
      poste: L.icon({
        iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-grey.png",
        shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41],
      }),
      nap: L.icon({
    iconUrl: "nap.png",
    shadowUrl: "icons/shadow.png",
    iconSize: [32, 32],
    iconAnchor: [16, 32],
    popupAnchor: [0, -28],
  }),
  fat: L.icon({
    iconUrl: "fat.png",
    shadowUrl: "icons/shadow.png",
    iconSize: [32, 32],
    iconAnchor: [16, 32],
    popupAnchor: [0, -28],
  }),
  olt: L.icon({
    iconUrl: "olt.png",
    shadowUrl: "icons/shadow.png",
    iconSize: [32, 32],
    iconAnchor: [16, 32],
    popupAnchor: [0, -28],
  }),
  fdh: L.icon({
    iconUrl: "c12.png",
    shadowUrl: "icons/shadow.png",
    iconSize: [32, 32],
    iconAnchor: [16, 32],
    popupAnchor: [0, -28],
  }),
emp: L.icon({
    iconUrl: "empalme.png",
    shadowUrl: "icons/shadow.png",
    iconSize: [32, 32],
    iconAnchor: [16, 32],
    popupAnchor: [0, -28],
  }),
pzo: L.icon({
    iconUrl: "pozo.png",
    shadowUrl: "icons/shadow.png",
    iconSize: [32, 32],
    iconAnchor: [16, 32],
    popupAnchor: [0, -28],
  }),
  default: L.icon({
    iconUrl: "icons/default.png",
    shadowUrl: "icons/shadow.png",
    iconSize: [32, 32],
    iconAnchor: [16, 32],
    popupAnchor: [0, -28],
  }),
      ont: L.icon({
    iconUrl: "ont.png",
    shadowUrl: "icons/shadow.png",
    iconSize: [32, 32],
    iconAnchor: [16, 32],
    popupAnchor: [0, -28],
  }),
    odf: L.icon({
    iconUrl: "odf.png",
    shadowUrl: "icons/shadow.png",
    iconSize: [32, 32],
    iconAnchor: [16, 32],
    popupAnchor: [0, -28],
    }),
    box: L.icon({
    iconUrl: "box.png",
    shadowUrl: "icons/shadow.png",
    iconSize: [32, 32],
    iconAnchor: [16, 32],
    popupAnchor: [0, -28],
      }),
      homepassed: L.icon({
        iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png",
        shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41],
      }),
      default: L.icon({
        iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png",
        shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41],
      }),
    };

    // =========================
    // Inicialización del mapa
    // =========================
    function initMap() {
      console.log("Inicializando mapa...");
      map = L.map("map").setView([13.6929, -89.2182], 13);

      standardTileLayer = L.tileLayer(
        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
        {
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
          maxZoom: 19,
        }
      );

      satelliteTileLayer = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {
          attribution: "Tiles &copy; Esri",
          maxZoom: 19,
        }
      );

      // Capa de Google Earth (Google Maps Satelital)
      googleEarthTileLayer = L.tileLayer(
        "https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}",
        {
          attribution: "Google Earth",
          maxZoom: 20,
          subdomains: ["mt0", "mt1", "mt2", "mt3"],
        }
      );

      standardTileLayer.addTo(map);

      // Click en mapa para agregar activo o dibujar cable
      map.on("click", function(e) {
        const type = document.getElementById("asset-type-selector").value;
        console.log("Click en mapa, tipo seleccionado:", type);
        if (type === "cab") {
          // Dibujo de cable
          if (!drawingCable) {
            startCableDrawing();
          }
          addCablePoint(e.latlng);
        } else if (type === "polygon") {
          // Dibujo de polígono
          if (!drawingPolygon) {
            startPolygonDrawing();
          }
          addPolygonPoint(e.latlng);
        } else {
          addAsset(e.latlng.lat, e.latlng.lng);
        }
      });

      // Doble clic para finalizar cable (mantenido por compatibilidad)
      map.on("dblclick", function(e) {
        if (drawingCable && cablePoints.length > 1) {
          finishCableDrawing();
        }
        if (drawingPolygon && polygonPoints.length > 2) {
          finishPolygonDrawing();
        }
      });
      
      console.log("Mapa inicializado correctamente");
    }

    // =========================
    // Funciones para el panel lateral
    // =========================
    function toggleSidebar() {
      const sidebar = document.getElementById("sidebar");
      const mapContainer = document.getElementById("map-container");
      const toggleIcon = document.getElementById("toggle-icon");
      
      sidebarExpanded = !sidebarExpanded;
      
      if (sidebarExpanded) {
        sidebar.classList.remove("hidden");
        mapContainer.classList.remove("expanded");
        toggleIcon.classList.remove("fa-chevron-right");
        toggleIcon.classList.add("fa-chevron-left");
      } else {
        sidebar.classList.add("hidden");
        mapContainer.classList.add("expanded");
        toggleIcon.classList.remove("fa-chevron-left");
        toggleIcon.classList.add("fa-chevron-right");
      }
      
      // Ajustar el mapa después de cambiar el tamaño del panel
      setTimeout(function() {
        map.invalidateSize();
      }, 300);
    }

    // =========================
    // Utilidades
    // =========================
    function generateId() {
      return Math.random().toString(36).substring(2, 10);
    }

    function escapeXML(str) {
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&apos;");
    }

    function downloadFile(filename, content, contentType) {
      const blob = new Blob([content], { type: contentType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // =========================
    // Funciones para el puntero estático
    // =========================
    function updateStaticCrosshair() {
      const assetType = document.getElementById("asset-type-selector").value;
      const staticCrosshair = document.getElementById("static-crosshair");
      const addAtPointerBtn = document.getElementById("add-at-pointer-btn");
      
      // Mostrar puntero estático cuando:
      // 1. Se selecciona un tipo de activo (excepto cable y polígono)
      // 2. Se está dibujando un cable o polígono
      if ((assetType !== "cab" && assetType !== "polygon") || drawingCable || drawingPolygon) {
        staticCrosshair.style.display = "block";
        addAtPointerBtn.style.display = "flex";
        staticCrosshairVisible = true;
      } else {
        staticCrosshair.style.display = "none";
        addAtPointerBtn.style.display = "none";
        staticCrosshairVisible = false;
      }
    }

    // Función para agregar activo en la posición del puntero
    function addAssetAtPointer() {
      if (!staticCrosshairVisible) return;
      
      // Obtener el centro del mapa (donde está el puntero)
      const center = map.getCenter();
      const type = document.getElementById("asset-type-selector").value;
      
      if (type === "cab") {
        if (!drawingCable) {
          startCableDrawing();
        }
        addCablePoint(center);
      } else if (type === "polygon") {
        if (!drawingPolygon) {
          startPolygonDrawing();
        }
        addPolygonPoint(center);
      } else {
        addAsset(center.lat, center.lng);
      }
    }

    // =========================
    // Persistencia
    // =========================
    function saveData() {
      // Convertimos las fotos a formato almacenable
      const assetsToSave = assets.map(function(asset) {
        if (asset.photo && asset.photo.startsWith('data:')) {
          // No guardamos datos de imagen grandes en localStorage
          const copy = {...asset};
          delete copy.photo;
          copy.hasPhoto = true;
          return copy;
        }
        return asset;
      });
      
      localStorage.setItem("fibermapper_assets", JSON.stringify(assetsToSave));
      localStorage.setItem("fibermapper_asset_counters", JSON.stringify(assetCounters));
      localStorage.setItem("fibermapper_map_type", currentMapType);
      localStorage.setItem("fibermapper_visibility", JSON.stringify(assetVisibility));
    }

    function loadSavedData() {
      const savedAssets = localStorage.getItem("fibermapper_assets");
      const savedMapType = localStorage.getItem("fibermapper_map_type");
      const savedCounters = localStorage.getItem("fibermapper_asset_counters");
      const savedVisibility = localStorage.getItem("fibermapper_visibility");

      if (savedAssets) {
        assets = JSON.parse(savedAssets);

        assets.forEach(function(asset) {
          if (asset.type === "cab" && asset.points) {
            addCableToMap(asset);
            // Reponer etiquetas de distancia
            if (asset.points.length > 1) {
              for (let i = 1; i < asset.points.length; i++) {
                const a = { lat: asset.points[i - 1][0], lng: asset.points[i - 1][1] };
                const b = { lat: asset.points[i][0], lng: asset.points[i][1] };
                const d = calculateDistance(a.lat, a.lng, b.lat, b.lng);
                addDistanceLabel(a, b, d);
              }
            }
          } else if (asset.type === "polygon" && asset.points) {
            addPolygonToMap(asset);
          } else if (asset.lat && asset.lng) {
            addMarker(asset);
          }
          addLabelToAsset(asset);
        });

        renderAssetsList();
        updateStats();
        calculateCableTotals();
      }

      if (savedCounters) {
        const counters = JSON.parse(savedCounters);
        Object.keys(counters).forEach(function(key) {
          if (assetCounters.hasOwnProperty(key)) {
            assetCounters[key] = counters[key];
          }
        });
      }

      if (savedMapType) switchMapType(savedMapType);
      
      if (savedVisibility) {
        assetVisibility = JSON.parse(savedVisibility);
        updateVisibilityControls();
        applyVisibility();
      }
    }

    // =========================
    // Activos (puntos)
    // =========================
    function addAsset(lat, lng, label, type, photo, description) {
  const assetType = type || document.getElementById("asset-type-selector").value;
  
  // Si no es cable, polígono ni homepassed, generar numeración automática
  if (assetType !== "cab" && assetType !== "polygon" && assetType !== "homepassed") {
    assetCounters[assetType] = (assetCounters[assetType] || 0) + 1;
  }

  const id = generateId();
  let assetLabel;

  // Etiqueta especial para Home Passed
  if (assetType === "homepassed") {
    assetLabel = "HP";
  } else {
    assetLabel = label || assetType.toUpperCase() + "_" + assetCounters[assetType];
  }

  const asset = {
    id: id,
    type: assetType,
    label: assetLabel,
    lat: Number(lat.toFixed(6)),
    lng: Number(lng.toFixed(6)),
    props: {
      description: description || ""
    },
  };

  // Agregar foto si está disponible
  if (photo) {
    asset.photo = photo;
  }

  assets.push(asset);
  
  if (assetType === "polygon") {
    // Para polígonos, no agregamos marcador, se maneja diferente
  } else {
    addMarker(asset);
  }
  
  addLabelToAsset(asset);
  renderAssetsList();
  updateStats();
  saveData();
  selectAsset(id);
  
  return asset;
}


    function addMarker(asset) {
  if (markers[asset.id]) map.removeLayer(markers[asset.id]);

  const icon = ICONS[asset.type] || ICONS.default;

  const marker = L.marker([asset.lat, asset.lng], {
    draggable: true,
    icon: icon,
  }).addTo(map);

  marker.on("dragend", function () {
    const p = marker.getLatLng();
    updateAsset(asset.id, {
      lat: Number(p.lat.toFixed(6)),
      lng: Number(p.lng.toFixed(6)),
    });
  });

  // Solo mostrar popup si NO es Home Passed
  if (asset.type !== "homepassed") {
    marker.on("click", function () {
      selectAsset(asset.id);
    });

    let popupContent = `
      <div class="popup-content">
        <div class="popup-title">${asset.label}</div>
        <div class="popup-coords">${asset.lat}, ${asset.lng}</div>
    `;
    
    if (asset.props && asset.props.description) {
      popupContent += `<div>${asset.props.description}</div>`;
    }
    
    if (asset.photo) {
      popupContent += `
        <div style="margin-top: 8px;">
          <img src="${asset.photo}" style="max-width: 150px; max-height: 100px; border-radius: 4px;">
        </div>
      `;
    }
    
    popupContent += `
        <div class="popup-actions">
          <button class="popup-btn" onclick="selectAsset('${asset.id}')">Editar</button>
          <button class="popup-btn" onclick="openPhotoModal('${asset.id}')">${asset.photo ? 'Cambiar Foto' : 'Agregar Foto'}</button>
          <button class="popup-btn" onclick="deleteAsset('${asset.id}')">Eliminar</button>
        </div>
      </div>
    `;

    marker.bindPopup(popupContent, { maxWidth: 300 });
  }

  markers[asset.id] = marker;

  // Aplicar visibilidad
  if (!assetVisibility[asset.type]) {
    map.removeLayer(marker);
  }
}


    function selectAsset(id) {
      selectedAssetId = id;
      const asset = assets.find(function(a) { return a.id === id; });

      if (asset) {
        document.getElementById("editor-id").textContent = asset.id;
        document.getElementById("editor-label").value = asset.label;
        document.getElementById("editor-type").value = asset.type;
        
        // Para polígonos, mostrar el primer punto como referencia
        if (asset.type === "polygon" && asset.points && asset.points.length > 0) {
          document.getElementById("editor-lat").value = asset.points[0][0] || "";
          document.getElementById("editor-lng").value = asset.points[0][1] || "";
        } else {
          document.getElementById("editor-lat").value = asset.lat || "";
          document.getElementById("editor-lng").value = asset.lng || "";
        }
        
        // Actualizar propiedades incluyendo descripción
        const props = asset.props || {};
        document.getElementById("editor-props").value = JSON.stringify(props, null, 2);

        document.getElementById("no-selection-message").style.display = "none";
        document.getElementById("editor-panel").style.display = "block";

        // resaltar en lista
        var assetItems = document.querySelectorAll(".asset-item");
        assetItems.forEach(function(el) {
          el.classList.toggle("selected", el.getAttribute("data-id") === asset.id);
        });

        if (markers[asset.id]) markers[asset.id].openPopup();
      }
    }

    function updateAsset(id, changes) {
      const idx = assets.findIndex(function(a) { return a.id === id; });
      if (idx === -1) return;
      const prev = assets[idx];
      const updated = { ...prev, ...changes };

      assets[idx] = updated;

      if (updated.type === "cab") {
        if (markers[updated.id]) {
          map.removeLayer(markers[updated.id]);
          delete markers[updated.id];
        }
        addCableToMap(updated);
      } else if (updated.type === "polygon") {
        if (markers[updated.id]) {
          map.removeLayer(markers[updated.id]);
          delete markers[updated.id];
        }
        addPolygonToMap(updated);
      } else {
        addMarker(updated);
      }

      // actualizar etiqueta
      if (labelLayers[updated.id]) {
        map.removeLayer(labelLayers[updated.id]);
        delete labelLayers[updated.id];
      }
      addLabelToAsset(updated);

      renderAssetsList();
      updateStats();
      calculateCableTotals();
      saveData();
    }

    function deleteAsset(id) {
      const asset = assets.find(function(a) { return a.id === id; });
      if (!asset) return;

      if (markers[id]) {
        map.removeLayer(markers[id]);
        delete markers[id];
      }
      if (polylines[id]) {
        map.removeLayer(polylines[id]);
        delete polylines[id];
      }
      if (polygons[id]) {
        map.removeLayer(polygons[id]);
        delete polygons[id];
      }
      if (labelLayers[id]) {
        map.removeLayer(labelLayers[id]);
        delete labelLayers[id];
      }

      // limpiar etiquetas de distancia de ese cable
      if (asset.type === "cab" && asset.points && asset.points.length > 1) {
        distanceLabels.forEach(function(m) { map.removeLayer(m); });
        distanceLabels = [];
      }

      assets = assets.filter(function(a) { return a.id !== id; });
      renderAssetsList();
      updateStats();
      calculateCableTotals();
      saveData();

      selectedAssetId = null;
      document.getElementById("editor-panel").style.display = "none";
      document.getElementById("no-selection-message").style.display = "block";
    }

    function renderAssetsList() {
      const list = document.getElementById("assets-list");
      const q = (document.getElementById("search-input").value || "").toLowerCase();
      list.innerHTML = "";

      assets
        .filter(function(a) { return (a.label || "").toLowerCase().includes(q); })
        .forEach(function(asset) {
          const el = document.createElement("div");
          el.className = "asset-item";
          el.setAttribute("data-id", asset.id);
          
          let assetInfo = `
            <div class="asset-header">
              <div class="asset-name">${asset.label}</div>
              <div class="asset-type">${asset.type.toUpperCase()}</div>
            </div>
          `;
          
          if (asset.type === "polygon") {
            assetInfo += `<div class="asset-coords">Polígono - ${asset.points ? asset.points.length : 0} vértices</div>`;
          } else {
            assetInfo += `<div class="asset-coords">${asset.lat || "—"}, ${asset.lng || "—"}</div>`;
          }
          
          // Mostrar icono de cámara si tiene foto
          if (asset.photo || asset.hasPhoto) {
            assetInfo += `<div style="margin-top:4px;"><i class="fas fa-camera" style="color:#3b82f6;"></i> Con foto</div>`;
          }
          
          el.innerHTML = assetInfo;
          el.addEventListener("click", function() { selectAsset(asset.id); });
          list.appendChild(el);
        });
    }

    function updateStats() {
      const totalAssets = assets.filter(function(a) { return a.type !== "cab" && a.type !== "polygon"; }).length;
      const totalCables = assets.filter(function(a) { return a.type === "cab"; }).length;
      const totalPolygons = assets.filter(function(a) { return a.type === "polygon"; }).length;
      const totalFO = assets
        .filter(function(a) { return a.type === "cab" && a.cableType === "fo"; })
        .reduce(function(s, a) { return s + (a.distance || 0); }, 0);

      document.getElementById("stat-assets").textContent = totalAssets;
      document.getElementById("stat-cables").textContent = totalCables;
      document.getElementById("stat-distance").textContent = totalFO.toFixed(0) + " m";
    }

    // =========================
    // Etiquetas en el mapa
    // =========================
    function addLabelToAsset(asset) {
      if (!asset.label) return;

      // Para cable muestra etiqueta en el centro aproximado
      let position = [asset.lat, asset.lng];
      if (asset.type === "cab" && asset.points && asset.points.length > 0) {
        const mid = Math.floor(asset.points.length / 2);
        position = [asset.points[mid][0], asset.points[mid][1]];
      } else if (asset.type === "polygon" && asset.points && asset.points.length > 0) {
        // Para polígonos, calcular el centroide
        let sumLat = 0, sumLng = 0;
        asset.points.forEach(function(point) {
          sumLat += point[0];
          sumLng += point[1];
        });
        position = [sumLat / asset.points.length, sumLng / asset.points.length];
        
        // Contar HOME PASSED dentro del polígono
        const homePassedCount = countHomePassedInPolygon(asset);
        if (homePassedCount > 0) {
          asset.homePassedCount = homePassedCount;
        }
      }

      let labelText = asset.label;
      
      if (asset.type === "cab" && asset.distance) {
        labelText += " (" + (asset.distance || 0).toFixed(0) + "m)";
      } else if (asset.type === "polygon" && asset.area) {
        labelText += " (" + (asset.area || 0).toFixed(0) + "m²)";
        if (asset.homePassedCount > 0) {
          labelText += " HP=" + asset.homePassedCount;
        }
      }

      const label = L.divIcon({
        className: "map-label",
        html: labelText,
        iconSize: [Math.max(labelText.length * 7, 24), 20],
        iconAnchor: [Math.max(labelText.length * 3.5, 12), 10],
      });

      const m = L.marker(position, { icon: label, interactive: false }).addTo(map);
      labelLayers[asset.id] = m;

      if (!showLabels) map.removeLayer(m);
      
      // Aplicar visibilidad
      if (!assetVisibility[asset.type]) {
        map.removeLayer(m);
      }
    }

    function addDistanceLabel(pointA, pointB, distance) {
      const midLat = (pointA.lat + pointB.lat) / 2;
      const midLng = (pointA.lng + pointB.lng) / 2;

      const label = L.divIcon({
        className: "distance-label",
        html: distance.toFixed(2) + "m",
        iconSize: [Math.max((distance.toFixed(2) + "m").length * 7, 24), 18],
        iconAnchor: [Math.max((distance.toFixed(2) + "m").length * 3.5, 12), 9],
      });

      const marker = L.marker([midLat, midLng], {
        icon: label,
        interactive: false,
      }).addTo(map);

      distanceLabels.push(marker);
      if (!showLabels) map.removeLayer(marker);
    }

    // =========================
    // Funciones de ubicación mejoradas
    // =========================
    function showCurrentLocation(position) {
      const lat = position.coords.latitude;
      const lng = position.coords.longitude;
      const accuracy = position.coords.accuracy;
      
      // Eliminar marcador anterior si existe
      if (currentLocationMarker) {
        map.removeLayer(currentLocationMarker);
      }
      if (currentAccuracyCircle) {
        map.removeLayer(currentAccuracyCircle);
      }
      
      // Crear marcador de ubicación
      currentLocationMarker = L.marker([lat, lng], {
        icon: L.icon({
          iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
          shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41]
        })
      }).addTo(map);
      
      // Crear círculo de precisión
      currentAccuracyCircle = L.circle([lat, lng], {
        radius: accuracy,
        color: '#00AA00',
        fillColor: '#00AA00',
        fillOpacity: 0.2,
        weight: 1
      }).addTo(map);
      
      // Centrar mapa en la ubicación
      map.setView([lat, lng], 17);
      
      // Agregar popup informativo
      currentLocationMarker.bindPopup(`
        <div class="popup-content">
          <div class="popup-title">Tu ubicación actual</div>
          <div class="popup-coords">${lat.toFixed(6)}, ${lng.toFixed(6)}</div>
          <div class="popup-coords">Precisión: ±${accuracy.toFixed(1)} metros</div>
          <div class="popup-actions">
            <button class="popup-btn" onclick="clearCurrentLocation()">Cerrar</button>
          </div>
        </div>
      `).openPopup();
    }
    
    function clearCurrentLocation() {
      if (currentLocationMarker) {
        map.removeLayer(currentLocationMarker);
        currentLocationMarker = null;
      }
      if (currentAccuracyCircle) {
        map.removeLayer(currentAccuracyCircle);
        currentAccuracyCircle = null;
      }
      
      // Detener seguimiento de ubicación si está activo
      if (locationWatchId !== null) {
        navigator.geolocation.clearWatch(locationWatchId);
        locationWatchId = null;
      }
      
      // Actualizar estado del botón
      isTrackingLocation = false;
      document.getElementById("locate-me-btn").classList.remove("active");
    }

    function toggleLocationTracking() {
      if (!navigator.geolocation) {
        alert("La geolocalización no es compatible con este navegador.");
        return;
      }
      
      if (isTrackingLocation) {
        // Desactivar seguimiento
        clearCurrentLocation();
        isTrackingLocation = false;
        document.getElementById("locate-me-btn").classList.remove("active");
      } else {
        // Activar seguimiento
        const options = {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 0
        };
        
        // Obtener ubicación actual
        navigator.geolocation.getCurrentPosition(
          showCurrentLocation,
          function(error) {
            let errorMsg = "Error al obtener la ubicación: ";
            switch(error.code) {
              case error.PERMISSION_DENIED:
                errorMsg += "Permiso denegado";
                break;
              case error.POSITION_UNAVAILABLE:
                errorMsg += "Posición no disponible";
                break;
              case error.TIMEOUT:
                errorMsg += "Tiempo de espera agotado";
                break;
              default:
                errorMsg += "Error desconocido";
            }
            alert(errorMsg);
          },
          options
        );
        
        // Iniciar seguimiento continuo
        locationWatchId = navigator.geolocation.watchPosition(
          showCurrentLocation,
          function(error) {
            console.error("Error en seguimiento de ubicación:", error);
          },
          options
        );
        
        isTrackingLocation = true;
        document.getElementById("locate-me-btn").classList.add("active");
      }
    }

    // =========================
    // Funciones para manejo de fotos
    // =========================
    function openPhotoModal(assetId) {
      currentAssetForPhoto = assetId;
      currentPhotoData = null;
      
      // Limpiar vista previa
      document.getElementById("photo-preview").style.display = "none";
      document.getElementById("photo-preview").src = "";
      
      // Mostrar modal
      document.getElementById("photo-modal").style.display = "flex";
    }

    function closePhotoModal() {
      document.getElementById("photo-modal").style.display = "none";
      currentAssetForPhoto = null;
      currentPhotoData = null;
    }

    function savePhoto() {
      if (!currentAssetForPhoto || !currentPhotoData) return;
      
      // Actualizar el asset con la foto
      updateAsset(currentAssetForPhoto, { photo: currentPhotoData });
      closePhotoModal();
    }

    function handlePhotoUpload(event, isCamera) {
      const file = event.target.files[0];
      if (!file) return;
      
      if (!file.type.match('image.*')) {
        alert("Por favor selecciona solo archivos de imagen");
        return;
      }
      
      const reader = new FileReader();
      reader.onload = function(e) {
        currentPhotoData = e.target.result;
        const preview = document.getElementById("photo-preview");
        preview.src = currentPhotoData;
        preview.style.display = "block";
      };
      reader.readAsDataURL(file);
    }

    // =========================
    // Cables - Funciones mejoradas
    // =========================
    function startCableDrawing() {
      drawingCable = true;
      cablePoints = [];
      
      // Mostrar controles de cable
      document.getElementById("cable-controls").style.display = "grid";
      document.getElementById("drawing-status").style.display = "block";
      document.getElementById("undo-cable-point").disabled = true;
      document.getElementById("finish-cable-drawing").disabled = true;
      
      // Actualizar puntero estático
      updateStaticCrosshair();
    }

    function addCablePoint(latlng) {
      if (!drawingCable) return;
      
      cablePoints.push(latlng);

      // Punto temporal
      const m = L.circleMarker(latlng, {
        radius: 5,
        color: currentCableType === "fo" ? "#3b82f6" : "#f59e0b",
        fillColor: currentCableType === "fo" ? "#3b82f6" : "#f59e0b",
        fillOpacity: 0.8,
      }).addTo(map);
      tempMarkers.push(m);

      // línea temporal
      if (cablePoints.length > 1) {
        const dashArray = currentCableInstallation === "aerial" ? "10, 10" : null;
        
        const pl = L.polyline(cablePoints, {
          color: currentCableType === "fo" ? "#3b82f6" : "#f59e0b",
          weight: 3,
          dashArray: dashArray,
        }).addTo(map);
        tempPolylines.push(pl);

        // totales
        const total = calculateTotalDistance(cablePoints);
        updateDistanceDisplay(total);

        // último segmento
        const last = calculateDistance(
          cablePoints[cablePoints.length - 2].lat,
          cablePoints[cablePoints.length - 2].lng,
          cablePoints[cablePoints.length - 1].lat,
          cablePoints[cablePoints.length - 1].lng
        );
        document.getElementById("segment-distance").textContent = "Último segmento: " + last.toFixed(2) + " metros";

        addDistanceLabel(
          cablePoints[cablePoints.length - 2],
          cablePoints[cablePoints.length - 1],
          last
        );
      }
      
      // Habilitar botones según cantidad de puntos
      document.getElementById("undo-cable-point").disabled = cablePoints.length === 0;
      document.getElementById("finish-cable-drawing").disabled = cablePoints.length < 2;
    }

    function undoLastCablePoint() {
      if (cablePoints.length === 0) return;
      
      // Eliminar último punto y elementos temporales asociados
      cablePoints.pop();
      
      // Eliminar marcador temporal
      if (tempMarkers.length > 0) {
        const lastMarker = tempMarkers.pop();
        map.removeLayer(lastMarker);
      }
      
      // Eliminar polyline temporal
      if (tempPolylines.length > 0) {
        const lastPolyline = tempPolylines.pop();
        map.removeLayer(lastPolyline);
      }
      
      // Eliminar etiqueta de distancia del último segmento
      if (distanceLabels.length > 0) {
        const lastLabel = distanceLabels.pop();
        map.removeLayer(lastLabel);
      }
      
      // Redibujar polyline si aún quedan puntos
      if (cablePoints.length > 1) {
        const dashArray = currentCableInstallation === "aerial" ? "10, 10" : null;
        
        const pl = L.polyline(cablePoints, {
          color: currentCableType === "fo" ? "#3b82f6" : "#f59e0b",
          weight: 3,
          dashArray: dashArray,
        }).addTo(map);
        tempPolylines.push(pl);
        
        // Recalcular distancia total
        const total = calculateTotalDistance(cablePoints);
        updateDistanceDisplay(total);
        
        // Actualizar último segmento
        if (cablePoints.length > 1) {
          const last = calculateDistance(
            cablePoints[cablePoints.length - 2].lat,
            cablePoints[cablePoints.length - 2].lng,
            cablePoints[cablePoints.length - 1].lat,
            cablePoints[cablePoints.length - 1].lng
          );
          document.getElementById("segment-distance").textContent = "Último segmento: " + last.toFixed(2) + " metros";
        } else {
          document.getElementById("segment-distance").textContent = "Último segmento: 0.00 metros";
        }
      } else {
        // Si solo queda un punto o ninguno
        updateDistanceDisplay(0);
        document.getElementById("segment-distance").textContent = "Último segmento: 0.00 metros";
      }
      
      // Actualizar estado de los botones
      document.getElementById("undo-cable-point").disabled = cablePoints.length === 0;
      document.getElementById("finish-cable-drawing").disabled = cablePoints.length < 2;
    }

    function cancelCableDrawing() {
      if (!drawingCable) return;
      
      // Limpiar todos los elementos temporales
      tempMarkers.forEach(function(m) { map.removeLayer(m); });
      tempPolylines.forEach(function(l) { map.removeLayer(l); });
      tempMarkers = [];
      tempPolylines = [];
      cablePoints = [];
      drawingCable = false;
      
      // Limpiar etiquetas de distancia temporales
      distanceLabels.forEach(function(label) { map.removeLayer(label); });
      distanceLabels = [];
      
      // Ocultar controles de cable
      document.getElementById("cable-controls").style.display = "none";
      document.getElementById("drawing-status").style.display = "none";
      
      // Restablecer displays de distancia
      updateDistanceDisplay(0);
      document.getElementById("segment-distance").textContent = "Último segmento: 0.00 metros";
      
      // Actualizar puntero estático
      updateStaticCrosshair();
    }

    function finishCableDrawing() {
      if (!drawingCable || cablePoints.length < 2) {
        cancelCableDrawing();
        return;
      }

      const id = generateId();
      const totalDistance = calculateTotalDistance(cablePoints);

      const asset = {
        id: id,
        type: "cab",
        cableType: currentCableType,
        installationType: currentCableInstallation,
        label: "CAB_" + id.substring(0, 4),
        points: cablePoints.map(function(p) { return [Number(p.lat.toFixed(6)), Number(p.lng.toFixed(6))]; }),
        distance: totalDistance,
        props: {},
      };

      assets.push(asset);

      // limpiar temporales
      tempMarkers.forEach(function(m) { map.removeLayer(m); });
      tempPolylines.forEach(function(l) { map.removeLayer(l); });
      tempMarkers = [];
      tempPolylines = [];
      cablePoints = [];
      drawingCable = false;

      // Ocultar controles de cable
      document.getElementById("cable-controls").style.display = "none";
      document.getElementById("drawing-status").style.display = "none";

      updateDistanceDisplay(0);
      document.getElementById("segment-distance").textContent = "Último segmento: 0.00 metros";

      addCableToMap(asset);
      addLabelToAsset(asset);
      renderAssetsList();
      updateStats();
      calculateCableTotals();
      saveData();
      selectAsset(id);
      
      // Actualizar puntero estático
      updateStaticCrosshair();
    }

    function addCableToMap(asset) {
      if (polylines[asset.id]) map.removeLayer(polylines[asset.id]);

      const dashArray = asset.installationType === "aerial" ? "10, 10" : null;
      
      const poly = L.polyline(asset.points, {
        color: asset.cableType === "fo" ? "#3b82f6" : "#f59e0b",
        weight: 4,
        dashArray: dashArray,
      }).addTo(map);

      poly.on("click", function() { selectAsset(asset.id); });

      const distance = asset.distance || 0;
      const installationType = asset.installationType === "aerial" ? "Aéreo" : "Ducto";
      
      poly.bindPopup(`
        <div class="popup-content">
          <div class="popup-title">${asset.label}</div>
          <div class="popup-coords">${distance.toFixed(2)} metros</div>
          <div class="popup-coords">Tipo: ${installationType}</div>
          <div class="popup-actions">
            <button class="popup-btn" onclick="selectAsset('${asset.id}')">Editar</button>
            <button class="popup-btn" onclick="deleteAsset('${asset.id}')">Eliminar</button>
          </div>
        </div>
      `);

      polylines[asset.id] = poly;
      
      // Aplicar visibilidad
      if (!assetVisibility[asset.type]) {
        map.removeLayer(poly);
      }
    }

    function calculateDistance(lat1, lng1, lat2, lng2) {
      const R = 6371000; // Radio de la Tierra en metros
      const dLat = ((lat2 - lat1) * Math.PI) / 180;
      const dLng = ((lng2 - lng1) * Math.PI) / 180;
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos((lat1 * Math.PI) / 180) *
          Math.cos((lat2 * Math.PI) / 180) *
          Math.sin(dLng / 2) *
          Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function calculateTotalDistance(points) {
      let total = 0;
      for (let i = 1; i < points.length; i++) {
        total += calculateDistance(
          points[i - 1].lat,
          points[i - 1].lng,
          points[i].lat,
          points[i].lng
        );
      }
      return total;
    }

    function updateDistanceDisplay(distance) {
      document.getElementById("cable-distance").textContent = "Distancia: " + distance.toFixed(2) + " metros";
    }

    function calculateCableTotals() {
      let totalFO = 0;
      let totalDrop = 0;

      assets
        .filter(function(a) { return a.type === "cab"; })
        .forEach(function(cable) {
          if (cable.cableType === "fo") {
            totalFO += cable.distance || 0;
          } else if (cable.cableType === "drop") {
            totalDrop += cable.distance || 0;
          }
        });

      document.getElementById("total-fo").textContent = totalFO.toFixed(0) + " m";
      document.getElementById("total-drop").textContent = totalDrop.toFixed(0) + " m";
    }

    // =========================
    // Polígonos - Funciones nuevas
    // =========================
    function startPolygonDrawing() {
      drawingPolygon = true;
      polygonPoints = [];
      
      // Mostrar controles de polígono
      document.getElementById("polygon-controls").style.display = "grid";
      document.getElementById("polygon-drawing-status").style.display = "block";
      document.getElementById("undo-polygon-point").disabled = true;
      document.getElementById("finish-polygon-drawing").disabled = true;
      
      // Actualizar puntero estático
      updateStaticCrosshair();
    }

    function addPolygonPoint(latlng) {
      if (!drawingPolygon) return;
      
      polygonPoints.push(latlng);

      // Punto temporal
      const m = L.circleMarker(latlng, {
        radius: 5,
        color: currentPolygonColor,
        fillColor: currentPolygonColor,
        fillOpacity: 0.8,
      }).addTo(map);
      tempPolygonMarkers.push(m);

      // Línea temporal
      if (polygonPoints.length > 1) {
        const pl = L.polyline(polygonPoints, {
          color: currentPolygonColor,
          weight: 2,
        }).addTo(map);
        tempPolygonLines.push(pl);
      }
      
      // Polígono temporal
      if (polygonPoints.length > 2) {
        if (tempPolygon) {
          map.removeLayer(tempPolygon);
        }
        
        tempPolygon = L.polygon(polygonPoints, {
          color: currentPolygonColor,
          weight: 2,
          fillColor: currentPolygonColor,
          fillOpacity: 0.4, // 40% de opacidad
        }).addTo(map);
        
        // Calcular área
        const area = calculatePolygonArea(polygonPoints);
        document.getElementById("polygon-area").textContent = "Área: " + area.toFixed(2) + " m²";
      }
      
      // Habilitar botones según cantidad de puntos
      document.getElementById("undo-polygon-point").disabled = polygonPoints.length === 0;
      document.getElementById("finish-polygon-drawing").disabled = polygonPoints.length < 3;
    }

    function undoLastPolygonPoint() {
      if (polygonPoints.length === 0) return;
      
      // Eliminar último punto y elementos temporales asociados
      polygonPoints.pop();
      
      // Eliminar marcador temporal
      if (tempPolygonMarkers.length > 0) {
        const lastMarker = tempPolygonMarkers.pop();
        map.removeLayer(lastMarker);
      }
      
      // Eliminar polyline temporal
      if (tempPolygonLines.length > 0) {
        const lastPolyline = tempPolygonLines.pop();
        map.removeLayer(lastPolyline);
      }
      
      // Redibujar polígono temporal si aún quedan puntos suficientes
      if (tempPolygon) {
        map.removeLayer(tempPolygon);
        tempPolygon = null;
      }
      
      if (polygonPoints.length > 2) {
        tempPolygon = L.polygon(polygonPoints, {
          color: currentPolygonColor,
          weight: 2,
          fillColor: currentPolygonColor,
          fillOpacity: 0.4,
        }).addTo(map);
        
        // Recalcular área
        const area = calculatePolygonArea(polygonPoints);
        document.getElementById("polygon-area").textContent = "Área: " + area.toFixed(2) + " m²";
      } else {
        document.getElementById("polygon-area").textContent = "Área: 0.00 m²";
      }
      
      // Actualizar estado de los botones
      document.getElementById("undo-polygon-point").disabled = polygonPoints.length === 0;
      document.getElementById("finish-polygon-drawing").disabled = polygonPoints.length < 3;
    }

    function cancelPolygonDrawing() {
      if (!drawingPolygon) return;
      
      // Limpiar todos los elementos temporales
      tempPolygonMarkers.forEach(function(m) { map.removeLayer(m); });
      tempPolygonLines.forEach(function(l) { map.removeLayer(l); });
      if (tempPolygon) {
        map.removeLayer(tempPolygon);
        tempPolygon = null;
      }
      tempPolygonMarkers = [];
      tempPolygonLines = [];
      polygonPoints = [];
      drawingPolygon = false;
      
      // Ocultar controles de polígono
      document.getElementById("polygon-controls").style.display = "none";
      document.getElementById("polygon-drawing-status").style.display = "none";
      
      // Restablecer display de área
      document.getElementById("polygon-area").textContent = "Área: 0.00 m²";
      
      // Actualizar puntero estático
      updateStaticCrosshair();
    }

    function finishPolygonDrawing() {
      if (!drawingPolygon || polygonPoints.length < 3) {
        cancelPolygonDrawing();
        return;
      }

      const id = generateId();
      const area = calculatePolygonArea(polygonPoints);

      const asset = {
        id: id,
        type: "polygon",
        label: "POLYGON_" + id.substring(0, 4),
        points: polygonPoints.map(function(p) { return [Number(p.lat.toFixed(6)), Number(p.lng.toFixed(6))]; }),
        area: area,
        color: currentPolygonColor,
        props: {},
      };

      assets.push(asset);

      // limpiar temporales
      tempPolygonMarkers.forEach(function(m) { map.removeLayer(m); });
      tempPolygonLines.forEach(function(l) { map.removeLayer(l); });
      if (tempPolygon) {
        map.removeLayer(tempPolygon);
        tempPolygon = null;
      }
      tempPolygonMarkers = [];
      tempPolygonLines = [];
      polygonPoints = [];
      drawingPolygon = false;

      // Ocultar controles de polígono
      document.getElementById("polygon-controls").style.display = "none";
      document.getElementById("polygon-drawing-status").style.display = "none";

      document.getElementById("polygon-area").textContent = "Área: 0.00 m²";

      addPolygonToMap(asset);
      addLabelToAsset(asset);
      renderAssetsList();
      updateStats();
      saveData();
      selectAsset(id);
      
      // Actualizar puntero estático
      updateStaticCrosshair();
    }

    function addPolygonToMap(asset) {
      if (polygons[asset.id]) map.removeLayer(polygons[asset.id]);

      const polygonColor = asset.color || currentPolygonColor;
      
      const polygon = L.polygon(asset.points, {
        color: polygonColor,
        weight: 2,
        fillColor: polygonColor,
        fillOpacity: 0.4, // 40% de opacidad
      }).addTo(map);

      polygon.on("click", function(e) {
        // Si no estamos en modo edición, seleccionar el polígono
        if (!editingPolygon) {
          selectAsset(asset.id);
          // Mostrar opción para editar
          if (confirm('¿Deseas editar este polígono?')) {
            startPolygonEdit(asset.id);
          }
        }
      });

      const area = asset.area || 0;
      const homePassedCount = countHomePassedInPolygon(asset);
      
      polygon.bindPopup(`
        <div class="popup-content">
          <div class="popup-title">${asset.label}</div>
          <div class="popup-coords">${area.toFixed(2)} m²</div>
          <div class="popup-coords">HOME PASSED: ${homePassedCount}</div>
          <div class="popup-actions">
            <button class="popup-btn" onclick="selectAsset('${asset.id}')">Editar</button>
            <button class="popup-btn" onclick="startPolygonEdit('${asset.id}')">Editar Vértices</button>
            <button class="popup-btn" onclick="deleteAsset('${asset.id}')">Eliminar</button>
          </div>
        </div>
      `);

      polygons[asset.id] = polygon;
      
      // Aplicar visibilidad
      if (!assetVisibility[asset.type]) {
        map.removeLayer(polygon);
      }
    }

    function calculatePolygonArea(points) {
      // Algoritmo para calcular el área de un polígono en metros cuadrados
      // Usando la fórmula del área del polígono esférico
      if (points.length < 3) return 0;
      
      let area = 0;
      const R = 6371000; // Radio de la Tierra en metros
      
      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        
        const lat1 = p1.lat * Math.PI / 180;
        const lng1 = p1.lng * Math.PI / 180;
        const lat2 = p2.lat * Math.PI / 180;
        const lng2 = p2.lng * Math.PI / 180;
        
        area += (lng2 - lng1) * (2 + Math.sin(lat1) + Math.sin(lat2));
      }
      
      area = area * R * R / 2;
      return Math.abs(area);
    }

    // =========================
    // Funciones para HOME PASSED
    // =========================
    function countHomePassedInPolygon(polygonAsset) {
      if (!polygonAsset || polygonAsset.type !== 'polygon' || !polygonAsset.points) {
        return 0;
      }
      
      // Crear un polígono Leaflet para verificar puntos dentro
      const polygon = L.polygon(polygonAsset.points);
      
      // Contar puntos HOME PASSED dentro del polígono
      let count = 0;
      assets.forEach(function(asset) {
        if (asset.type === 'homepassed' && asset.lat && asset.lng) {
          const point = L.latLng(asset.lat, asset.lng);
          if (polygon.getBounds().contains(point)) {
            // Verificación más precisa usando el algoritmo de punto en polígono
            if (isPointInPolygon([asset.lat, asset.lng], polygonAsset.points)) {
              count++;
            }
          }
        }
      });
      
      return count;
    }

    function isPointInPolygon(point, polygon) {
      // Algoritmo de punto en polígono (ray casting)
      const x = point[0], y = point[1];
      let inside = false;
      
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i][0], yi = polygon[i][1];
        const xj = polygon[j][0], yj = polygon[j][1];
        
        const intersect = ((yi > y) !== (yj > y)) &&
          (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        
        if (intersect) inside = !inside;
      }
      
      return inside;
    }

    // =========================
    // Funciones para edición de polígonos
    // =========================

    function startPolygonEdit(polygonId) {
      const asset = assets.find(function(a) { return a.id === polygonId; });
      if (!asset || asset.type !== 'polygon') return;

      currentEditingPolygonId = polygonId;
      editingPolygon = true;
      
      // Guardar puntos originales para posible cancelación
      originalPolygonPoints = [...asset.points];
      
      // Ocultar el polígono original
      if (polygons[polygonId]) {
        map.removeLayer(polygons[polygonId]);
      }
      
      // Mostrar controles de edición
      document.getElementById("polygon-edit-controls").style.display = "grid";
      document.getElementById("polygon-edit-status").style.display = "block";
      
      // Crear marcadores para cada vértice
      createVertexMarkers(asset.points);
      
      // Dibujar polígono temporal para edición
      drawEditingPolygon(asset.points);
      
      // Cambiar el comportamiento del click en el mapa
      map.off('click');
      map.on('click', handleMapClickDuringEdit);
    }

    function createVertexMarkers(points) {
      // Limpiar marcadores anteriores
      clearVertexMarkers();
      
      // Crear marcadores para cada vértice
      points.forEach(function(point, index) {
        const marker = L.marker([point[0], point[1]], {
          icon: L.divIcon({
            className: 'vertex-marker',
            iconSize: [12, 12],
            iconAnchor: [6, 6]
          }),
          draggable: true
        }).addTo(map);
        
        marker.on('drag', function(e) {
          // Actualizar la posición del punto
          const newPoint = [e.target.getLatLng().lat, e.target.getLatLng().lng];
          updatePolygonPoint(index, newPoint);
        });
        
        marker.on('contextmenu', function(e) {
          // Eliminar vértice con click derecho
          if (points.length > 3) {
            removePolygonPoint(index);
          } else {
            alert('Un polígono debe tener al menos 3 vértices');
          }
          e.originalEvent.preventDefault();
        });
        
        vertexMarkers.push(marker);
        
        // Crear marcadores de punto medio entre vértices
        if (index < points.length - 1) {
          createMidpointMarker(points[index], points[index + 1], index);
        }
      });
      
      // Punto medio entre el último y el primer vértice
      if (points.length > 2) {
        createMidpointMarker(points[points.length - 1], points[0], points.length - 1);
      }
    }

    function createMidpointMarker(pointA, pointB, index) {
      const midLat = (pointA[0] + pointB[0]) / 2;
      const midLng = (pointA[1] + pointB[1]) / 2;
      
      const marker = L.marker([midLat, midLng], {
        icon: L.divIcon({
          className: 'midpoint-marker',
          iconSize: [8, 8],
          iconAnchor: [4, 4]
        })
      }).addTo(map);
      
      marker.on('click', function() {
        // Agregar nuevo vértice en el punto medio
        addPolygonPointAt(index + 1, [midLat, midLng]);
      });
      
      midpointMarkers.push(marker);
    }

    function updatePolygonPoint(index, newPoint) {
      const asset = assets.find(function(a) { return a.id === currentEditingPolygonId; });
      if (!asset) return;
      
      // Actualizar el punto
      asset.points[index] = [Number(newPoint[0].toFixed(6)), Number(newPoint[1].toFixed(6))];
      
      // Redibujar el polígono
      drawEditingPolygon(asset.points);
      
      // Recrear marcadores de puntos medios
      updateMidpointMarkers(asset.points);
      
      // Actualizar área
      const area = calculatePolygonArea(asset.points.map(function(p) { return {lat: p[0], lng: p[1]}; }));
      document.getElementById("polygon-area").textContent = "Área: " + area.toFixed(2) + " m²";
    }

    function addPolygonPointAt(index, point) {
      const asset = assets.find(function(a) { return a.id === currentEditingPolygonId; });
      if (!asset) return;
      
      // Insertar nuevo punto
      asset.points.splice(index, 0, [Number(point[0].toFixed(6)), Number(point[1].toFixed(6))]);
      
      // Redibujar todo
      clearVertexMarkers();
      createVertexMarkers(asset.points);
      drawEditingPolygon(asset.points);
      
      // Actualizar área
      const area = calculatePolygonArea(asset.points.map(function(p) { return {lat: p[0], lng: p[1]}; }));
      document.getElementById("polygon-area").textContent = "Área: " + area.toFixed(2) + " m²";
    }

    function removePolygonPoint(index) {
      const asset = assets.find(function(a) { return a.id === currentEditingPolygonId; });
      if (!asset || asset.points.length <= 3) return;
      
      // Eliminar punto
      asset.points.splice(index, 1);
      
      // Redibujar todo
      clearVertexMarkers();
      createVertexMarkers(asset.points);
      drawEditingPolygon(asset.points);
      
      // Actualizar área
      const area = calculatePolygonArea(asset.points.map(function(p) { return {lat: p[0], lng: p[1]}; }));
      document.getElementById("polygon-area").textContent = "Área: " + area.toFixed(2) + " m²";
    }

    function drawEditingPolygon(points) {
      // Eliminar polígono temporal anterior si existe
      if (tempPolygon) {
        map.removeLayer(tempPolygon);
      }
      
      const asset = assets.find(function(a) { return a.id === currentEditingPolygonId; });
      const polygonColor = asset ? (asset.color || currentPolygonColor) : currentPolygonColor;
      
      // Crear nuevo polígono temporal
      tempPolygon = L.polygon(points, {
        color: polygonColor,
        weight: 2,
        fillColor: polygonColor,
        fillOpacity: 0.4,
        dashArray: '5, 5' // Líneas punteadas para indicar modo edición
      }).addTo(map);
    }

    function updateMidpointMarkers(points) {
      // Eliminar marcadores de puntos medios anteriores
      midpointMarkers.forEach(function(marker) { map.removeLayer(marker); });
      midpointMarkers = [];
      
      // Crear nuevos marcadores de puntos medios
      for (let i = 0; i < points.length; i++) {
        const nextIndex = (i + 1) % points.length;
        createMidpointMarker(points[i], points[nextIndex], i);
      }
    }

    function handleMapClickDuringEdit(e) {
      if (!editingPolygon) return;
      
      // Agregar nuevo vértice en la posición del click
      const asset = assets.find(function(a) { return a.id === currentEditingPolygonId; });
      if (!asset) return;
      
      // Encontrar el segmento más cercano al click
      const closestSegmentIndex = findClosestSegment(asset.points, e.latlng);
      
      if (closestSegmentIndex !== -1) {
        const insertIndex = closestSegmentIndex + 1;
        addPolygonPointAt(insertIndex, [e.latlng.lat, e.latlng.lng]);
      }
    }

    function findClosestSegment(points, latlng) {
      let closestIndex = -1;
      let minDistance = Infinity;
      
      for (let i = 0; i < points.length; i++) {
        const nextIndex = (i + 1) % points.length;
        const pointA = L.latLng(points[i][0], points[i][1]);
        const pointB = L.latLng(points[nextIndex][0], points[nextIndex][1]);
        
        const distance = distanceToSegment(latlng, pointA, pointB);
        
        if (distance < minDistance) {
          minDistance = distance;
          closestIndex = i;
        }
      }
      
      return closestIndex;
    }

    function distanceToSegment(point, segmentStart, segmentEnd) {
      const x = point.lat, y = point.lng;
      const x1 = segmentStart.lat, y1 = segmentStart.lng;
      const x2 = segmentEnd.lat, y2 = segmentEnd.lng;
      
      const A = x - x1;
      const B = y - y1;
      const C = x2 - x1;
      const D = y2 - y1;
      
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = -1;
      
      if (lenSq !== 0) {
        param = dot / lenSq;
      }
      
      let xx, yy;
      
      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x2;
        yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }
      
      const dx = x - xx;
      const dy = y - yy;
      
      return Math.sqrt(dx * dx + dy * dy);
    }

    function savePolygonEdit() {
      if (!editingPolygon || !currentEditingPolygonId) return;
      
      const asset = assets.find(function(a) { return a.id === currentEditingPolygonId; });
      if (!asset) return;
      
      // Actualizar el área
      asset.area = calculatePolygonArea(asset.points.map(function(p) { return {lat: p[0], lng: p[1]}; }));
      
      // Limpiar modo edición
      finishPolygonEdit();
      
      // Redibujar el polígono permanente
      addPolygonToMap(asset);
      
      // Actualizar etiqueta
      if (labelLayers[asset.id]) {
        map.removeLayer(labelLayers[asset.id]);
        delete labelLayers[asset.id];
      }
      addLabelToAsset(asset);
      
      // Guardar datos
      saveData();
      
      alert('Cambios guardados correctamente');
    }

    function cancelPolygonEdit() {
      if (!editingPolygon || !currentEditingPolygonId) return;
      
      const asset = assets.find(function(a) { return a.id === currentEditingPolygonId; });
      if (asset) {
        // Restaurar puntos originales
        asset.points = [...originalPolygonPoints];
        asset.area = calculatePolygonArea(asset.points.map(function(p) { return {lat: p[0], lng: p[1]}; }));
        
        // Redibujar el polígono permanente
        addPolygonToMap(asset);
      }
      
      // Limpiar modo edición
      finishPolygonEdit();
      
      alert('Edición cancelada');
    }

    function finishPolygonEdit() {
      // Limpiar marcadores
      clearVertexMarkers();
      
      // Eliminar polígono temporal
      if (tempPolygon) {
        map.removeLayer(tempPolygon);
        tempPolygon = null;
      }
      
      // Restaurar comportamiento normal del mapa
      map.off('click');
      map.on('click', function(e) {
        const type = document.getElementById("asset-type-selector").value;
        if (type === "cab") {
          if (!drawingCable) {
            startCableDrawing();
          }
          addCablePoint(e.latlng);
        } else if (type === "polygon") {
          if (!drawingPolygon) {
            startPolygonDrawing();
          }
          addPolygonPoint(e.latlng);
        } else {
          addAsset(e.latlng.lat, e.latlng.lng);
        }
      });
      
      // Ocultar controles de edición
      document.getElementById("polygon-edit-controls").style.display = "none";
      document.getElementById("polygon-edit-status").style.display = "none";
      
      editingPolygon = false;
      currentEditingPolygonId = null;
      originalPolygonPoints = [];
    }

    function clearVertexMarkers() {
      vertexMarkers.forEach(function(marker) { map.removeLayer(marker); });
      midpointMarkers.forEach(function(marker) { map.removeLayer(marker); });
      vertexMarkers = [];
      midpointMarkers = [];
    }

    // =========================
    // Control de visibilidad
    // =========================
    function updateVisibilityControls() {
      const container = document.getElementById("visibility-controls");
      container.innerHTML = "";
      
      Object.keys(assetVisibility).forEach(function(type) {
        const item = document.createElement("div");
        item.className = "visibility-item";
        
        const label = document.createElement("span");
        label.className = "visibility-label";
        label.textContent = type.toUpperCase();
        
        const switchContainer = document.createElement("label");
        switchContainer.className = "switch";
        
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = assetVisibility[type];
        checkbox.addEventListener("change", function() {
          assetVisibility[type] = this.checked;
          applyVisibility();
          saveData();
        });
        
        const slider = document.createElement("span");
        slider.className = "slider";
        
        switchContainer.appendChild(checkbox);
        switchContainer.appendChild(slider);
        
        item.appendChild(label);
        item.appendChild(switchContainer);
        container.appendChild(item);
      });
    }

    function applyVisibility() {
      // Aplicar visibilidad a todos los activos
      assets.forEach(function(asset) {
        if (asset.type === "cab" && polylines[asset.id]) {
          if (assetVisibility[asset.type]) {
            map.addLayer(polylines[asset.id]);
          } else {
            map.removeLayer(polylines[asset.id]);
          }
        } else if (asset.type === "polygon" && polygons[asset.id]) {
          if (assetVisibility[asset.type]) {
            map.addLayer(polygons[asset.id]);
          } else {
            map.removeLayer(polygons[asset.id]);
          }
        } else if (markers[asset.id]) {
          if (assetVisibility[asset.type]) {
            map.addLayer(markers[asset.id]);
          } else {
            map.removeLayer(markers[asset.id]);
          }
        }
        
        // Aplicar visibilidad a etiquetas
        if (labelLayers[asset.id]) {
          if (assetVisibility[asset.type] && showLabels) {
            map.addLayer(labelLayers[asset.id]);
          } else {
            map.removeLayer(labelLayers[asset.id]);
          }
        }
      });
    }

    // =========================
    // Selector de tipo de mapa
    // =========================
    function switchMapType(type) {
      if (currentMapType === type) return;

      // Remover todas las capas de mapa existentes
      map.removeLayer(standardTileLayer);
      map.removeLayer(satelliteTileLayer);
      map.removeLayer(googleEarthTileLayer);

      // Añadir la capa seleccionada
      if (type === "standard") {
        standardTileLayer.addTo(map);
        document.getElementById("standard-map-btn").classList.add("active");
        document.getElementById("satellite-map-btn").classList.remove("active");
        document.getElementById("googleearth-map-btn").classList.remove("active");
      } else if (type === "satellite") {
        satelliteTileLayer.addTo(map);
        document.getElementById("satellite-map-btn").classList.add("active");
        document.getElementById("standard-map-btn").classList.remove("active");
        document.getElementById("googleearth-map-btn").classList.remove("active");
      } else if (type === "googleearth") {
        googleEarthTileLayer.addTo(map);
        document.getElementById("googleearth-map-btn").classList.add("active");
        document.getElementById("standard-map-btn").classList.remove("active");
        document.getElementById("satellite-map-btn").classList.remove("active");
      }

      currentMapType = type;
      localStorage.setItem("fibermapper_map_type", type);
    }

    function toggleLabels() {
      showLabels = !showLabels;

      Object.values(labelLayers).forEach(function(layer) {
        if (showLabels) {
          map.addLayer(layer);
        } else {
          map.removeLayer(layer);
        }
      });

      distanceLabels.forEach(function(label) {
        if (showLabels) {
          map.addLayer(label);
        } else {
          map.removeLayer(label);
        }
      });
    }

    function exportData(format) {
      if (format === "csv") {
        exportToCSV();
      } else if (format === "kml") {
        exportToKML();
      }
    }

    function exportToCSV() {
      let csvContent = "ID,Tipo,Etiqueta,Latitud,Longitud,Distancia,Área,Instalación,Descripción,Foto,HOME_PASSED\n";

      assets.forEach(function(asset) {
        const installationType = asset.installationType === "aerial" ? "Aéreo" : (asset.installationType === "duct" ? "Ducto" : "N/A");
        const homePassedCount = asset.type === "polygon" ? countHomePassedInPolygon(asset) : "";
        
        const row = [
          asset.id,
          asset.type,
          '"' + (asset.label || "") + '"',
          asset.lat || "",
          asset.lng || "",
          asset.distance || "",
          asset.area || "",
          installationType,
          '"' + ((asset.props && asset.props.description) || "") + '"',
          asset.photo ? "Sí" : "No",
          homePassedCount
        ].join(",");
        csvContent += row + "\n";
      });

      const filename = "fibermapper_export_" + new Date().toISOString().slice(0, 10) + ".csv";
      downloadFile(filename, csvContent, "text/csv;charset=utf-8;");
    }

    function exportToKML(forWhatsApp = false) {
      let kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Fiber Mapper Export</name>
    <description>Exportado desde Fiber Mapper</description>`;

      // Mapeo de iconos según tipo de activo
      const iconMap = {
        poste: "http://maps.google.com/mapfiles/kml/paddle/P.png",
        nap: "http://maps.google.com/mapfiles/kml/paddle/N.png",
        fat: "http://maps.google.com/mapfiles/kml/paddle/F.png",
        fdh: "http://maps.google.com/mapfiles/kml/paddle/C.png",
        ont: "http://maps.google.com/mapfiles/kml/paddle/C.png",
        odf: "http://maps.google.com/mapfiles/kml/paddle/O.png",
        box: "http://maps.google.com/mapfiles/kml/paddle/B.png",
        homepassed: "http://maps.google.com/mapfiles/kml/paddle/H.png"
      };

      // Agregar estilos para activos con foto
      kmlContent += `
    <Style id="photoStyle">
      <IconStyle>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/pal4/icon57.png</href>
        </Icon>
      </IconStyle>
    </Style>`;

      // Añadir marcadores
      assets
        .filter(function(asset) { return asset.type !== "cab" && asset.type !== "polygon"; })
        .forEach(function(asset) {
          const hasPhoto = asset.photo ? ' styleUrl="#photoStyle"' : '';
          const iconUrl = iconMap[asset.type] || "http://maps.google.com/mapfiles/kml/paddle/wht-blank.png";
          
          kmlContent += `
    <Placemark${hasPhoto}>
      <name>${escapeXML(asset.label)}</name>
      <description>
        <![CDATA[
          <div style="font-family: Arial, sans-serif; max-width: 300px;">
            <h3 style="margin: 0 0 10px 0; color: #1e40af;">${escapeXML(asset.label)}</h3>
            <p><strong>Tipo:</strong> ${asset.type}</p>
            <p><strong>Coordenadas:</strong> ${asset.lat}, ${asset.lng}</p>
            ${asset.props && asset.props.description ? '<p><strong>Descripción:</strong> ' + escapeXML(asset.props.description) + '</p>' : ''}
            ${asset.photo ? '<img src="' + asset.photo + '" style="max-width: 100%; border-radius: 5px; margin-top: 10px;">' : ''}
          </div>
        ]]>
      </description>
      <Style>
        <IconStyle>
          <Icon>
            <href>${iconUrl}</href>
          </Icon>
        </IconStyle>
      </Style>
      <Point>
        <coordinates>${asset.lng},${asset.lat},0</coordinates>
      </Point>
    </Placemark>`;
        });

      // Añadir cables (líneas + etiquetas intermedias)
      assets
        .filter(function(asset) { return asset.type === "cab"; })
        .forEach(function(asset) {
          const color = asset.cableType === "fo" ? "ff0000ff" : "ff00aaff"; // Azul FO, cian DROP

          // Cable completo
          kmlContent += `
    <Placemark>
      <name>${escapeXML(asset.label)} (${asset.distance.toFixed(2)} m)</name>
      <description>${asset.distance.toFixed(2)} metros - Tipo: ${asset.cableType} - Instalación: ${asset.installationType === "aerial" ? "Aéreo" : "Ducto"}</description>
      <Style>
        <LineStyle>
          <color>${color}</color>
          <width>4</width>
          ${asset.installationType === "aerial" ? '<gx:physicalWidth>2</gx:physicalWidth>' : ''}
        </LineStyle>
      </Style>
      <LineString>
        <coordinates>${asset.points.map(function(p) { return p[1] + "," + p[0] + ",0"; }).join(" ")}</coordinates>
      </LineString>
    </Placemark>`;

          // Tramos intermedios con etiquetas
          for (let i = 0; i < asset.points.length - 1; i++) {
            const [lat1, lng1] = asset.points[i];
            const [lat2, lng2] = asset.points[i + 1];

            // Calcular distancia en metros
            const dist = calculateDistance(lat1, lng1, lat2, lng2);

            // Punto medio
            const midLat = (lat1 + lat2) / 2;
            const midLng = (lng1 + lng2) / 2;

            // Etiqueta en el punto medio
            kmlContent += `
    <Placemark>
      <name>${dist.toFixed(2)} m</name>
      <Style>
        <IconStyle>
          <scale>0</scale> <!-- Ocultamos el ícono -->
        </IconStyle>
        <LabelStyle>
          <color>ffffffff</color> <!-- Blanco -->
          <scale>1</scale>
        </LabelStyle>
      </Style>
      <Point>
        <coordinates>${midLng},${midLat},0</coordinates>
      </Point>
    </Placemark>`;
          }
        });

      // Añadir polígonos
      assets
        .filter(function(asset) { return asset.type === "polygon"; })
        .forEach(function(asset) {
          const color = asset.color ? hexToKMLColor(asset.color) : "ff10b981"; // Verde para polígonos
          const homePassedCount = countHomePassedInPolygon(asset);
          
          kmlContent += `
    <Placemark>
      <name>${escapeXML(asset.label)} (${asset.area.toFixed(2)} m²) HP=${homePassedCount}</name>
      <description>${asset.area.toFixed(2)} metros cuadrados - HOME PASSED: ${homePassedCount}</description>
      <Style>
        <LineStyle>
          <color>${color}</color>
          <width>2</width>
        </LineStyle>
        <PolyStyle>
          <color>40${color.substring(2)}</color> <!-- 40% de opacidad -->
        </PolyStyle>
      </Style>
      <Polygon>
        <outerBoundaryIs>
          <LinearRing>
            <coordinates>${asset.points.map(function(p) { return p[1] + "," + p[0] + ",0"; }).join(" ")} ${asset.points[0][1]},${asset.points[0][0]},0</coordinates>
          </LinearRing>
        </outerBoundaryIs>
      </Polygon>
    </Placemark>`;
        });

      kmlContent += `
  </Document>
</kml>`;

      if (forWhatsApp) {
        // Para WhatsApp, crear un blob y compartirlo
        const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
        const url = URL.createObjectURL(blob);
        
        // Crear un enlace temporal para descargar el archivo
        const a = document.createElement('a');
        a.href = url;
        a.download = "fibermapper_export_" + new Date().toISOString().slice(0, 10) + ".kml";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        // Esperar un momento antes de abrir WhatsApp para dar tiempo a la descarga
        setTimeout(function() {
          const text = encodeURIComponent("Te comparto el archivo KML de la infraestructura FTTX");
          window.open("https://wa.me/?text=" + text, '_blank');
        }, 1000);
      } else {
        // Descarga normal
        const filename = "fibermapper_export_" + new Date().toISOString().slice(0, 10) + ".kml";
        downloadFile(filename, kmlContent, "application/vnd.google-earth.kml+xml;charset=utf-8;");
      }
    }

    function hexToKMLColor(hex) {
      // Convertir color HEX a formato KML (AABBGGRR)
      hex = hex.replace('#', '');
      if (hex.length === 3) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
      }
      const r = hex.substring(0, 2);
      const g = hex.substring(2, 4);
      const b = hex.substring(4, 6);
      return "ff" + b + g + r;
    }

    function shareViaWhatsApp(format) {
      if (format === "csv") {
        const csvContent = generateCSVContent();
        const text = encodeURIComponent("Datos Fiber Mapper:\n" + csvContent);
        window.open("https://wa.me/?text=" + text, '_blank');
      } else if (format === "kml") {
        // Para KML, necesitamos crear un archivo temporal
        exportToKML(true);
      }
    }

    function generateCSVContent() {
      let csvContent = "ID,Tipo,Etiqueta,Latitud,Longitud,Distancia,Área,Instalación,Descripción,Foto,HOME_PASSED\n";
      assets.forEach(function(asset) {
        const installationType = asset.installationType === "aerial" ? "Aéreo" : (asset.installationType === "duct" ? "Ducto" : "N/A");
        const homePassedCount = asset.type === "polygon" ? countHomePassedInPolygon(asset) : "";
        
        const row = [
          asset.id,
          asset.type,
          '"' + (asset.label || "") + '"',
          asset.lat || "",
          asset.lng || "",
          asset.distance || "",
          asset.area || "",
          installationType,
          '"' + ((asset.props && asset.props.description) || "") + '"',
          asset.photo ? "Sí" : "No",
          homePassedCount
        ].join(",");
        csvContent += row + "\n";
      });
      return csvContent;
    }

    // =========================
    // Importación de datos - CORREGIDA
    // =========================
    function importKML(content) {
      try {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(content, "text/xml");
        
        // Verificar si hay errores en el XML
        const parseError = xmlDoc.getElementsByTagName("parsererror");
        if (parseError.length > 0) {
          alert("Error al parsear el archivo KML: " + parseError[0].textContent);
          return;
        }
        
        // Procesar Placemarks
        const placemarks = xmlDoc.getElementsByTagName("Placemark");
        let importedCount = 0;
        
        for (let i = 0; i < placemarks.length; i++) {
          const placemark = placemarks[i];
          
          // Obtener nombre
          const nameElement = placemark.getElementsByTagName("name")[0];
          const name = nameElement ? nameElement.textContent : "IMPORT_" + (i+1);
          
          // Obtener descripción
          const descElement = placemark.getElementsByTagName("description")[0];
          let description = "";
          if (descElement) {
            description = descElement.textContent;
          }
          
          // Determinar el tipo basado en el nombre o geometría
          let assetType = "poste"; // valor por defecto
          
          // Detectar tipo por nombre
          const nameUpper = name.toUpperCase();
          if (nameUpper.includes("NAP")) assetType = "nap";
          else if (nameUpper.includes("POSTE")) assetType = "poste";
          else if (nameUpper.includes("CABLE") || nameUpper.includes("CAB")) assetType = "cab";
          else if (nameUpper.includes("FAT")) assetType = "fat";
          else if (nameUpper.includes("OLT")) assetType = "olt";
          else if (nameUpper.includes("FDH")) assetType = "fdh";
          else if (nameUpper.includes("EMP")) assetType = "emp";
          else if (nameUpper.includes("POZO") || nameUpper.includes("PZO")) assetType = "pzo";
          else if (nameUpper.includes("ONT")) assetType = "ont";
          else if (nameUpper.includes("ODF")) assetType = "odf";
          else if (nameUpper.includes("BOX")) assetType = "box";
          else if (nameUpper.includes("POLYGON") || nameUpper.includes("POLIGONO")) assetType = "polygon";
          else if (nameUpper.includes("HOME") || nameUpper.includes("HP")) assetType = "homepassed";
          
          // Procesar geometrías
          const point = placemark.getElementsByTagName("Point")[0];
          const lineString = placemark.getElementsByTagName("LineString")[0];
          const polygonElement = placemark.getElementsByTagName("Polygon")[0];
          
          if (point) {
            // Es un punto
            const coordsElement = point.getElementsByTagName("coordinates")[0];
            if (coordsElement) {
              const coords = coordsElement.textContent.trim().split(",");
              if (coords.length >= 2) {
                const lng = parseFloat(coords[0]);
                const lat = parseFloat(coords[1]);
                
                if (!isNaN(lat) && !isNaN(lng)) {
                  addAsset(lat, lng, name, assetType, null, description);
                  importedCount++;
                }
              }
            }
          } else if (lineString) {
            // Es una línea (cable)
            const coordsElement = lineString.getElementsByTagName("coordinates")[0];
            if (coordsElement) {
              const coordPairs = coordsElement.textContent.trim().split(" ");
              const points = [];
              
              for (let j = 0; j < coordPairs.length; j++) {
                const coords = coordPairs[j].split(",");
                if (coords.length >= 2) {
                  const lng = parseFloat(coords[0]);
                  const lat = parseFloat(coords[1]);
                  
                  if (!isNaN(lat) && !isNaN(lng)) {
                    points.push([lat, lng]);
                  }
                }
              }
              
              if (points.length >= 2) {
                const id = generateId();
                const totalDistance = calculateTotalDistance(points.map(function(p) { return {lat: p[0], lng: p[1]}; }));
                
                const asset = {
                  id: id,
                  type: "cab",
                  cableType: "fo", // Por defecto
                  installationType: "aerial", // Por defecto
                  label: name,
                  points: points,
                  distance: totalDistance,
                  props: { description: description },
                };
                
                assets.push(asset);
                addCableToMap(asset);
                addLabelToAsset(asset);
                importedCount++;
              }
            }
          } else if (polygonElement) {
            // Es un polígono - CORREGIDO
            const outerBoundary = polygonElement.getElementsByTagName("outerBoundaryIs")[0];
            if (outerBoundary) {
              const linearRing = outerBoundary.getElementsByTagName("LinearRing")[0];
              if (linearRing) {
                const coordsElement = linearRing.getElementsByTagName("coordinates")[0];
                if (coordsElement) {
                  const coordPairs = coordsElement.textContent.trim().split(" ");
                  const points = [];
                  
                  for (let j = 0; j < coordPairs.length; j++) {
                    const coords = coordPairs[j].split(",");
                    if (coords.length >= 2) {
                      const lng = parseFloat(coords[0]);
                      const lat = parseFloat(coords[1]);
                      
                      if (!isNaN(lat) && !isNaN(lng)) {
                        points.push([lat, lng]);
                      }
                    }
                  }
                  
                  // Eliminar el último punto si es igual al primero (cierre del polígono)
                  if (points.length > 0 && 
                      points[0][0] === points[points.length-1][0] && 
                      points[0][1] === points[points.length-1][1]) {
                    points.pop();
                  }
                  
                  if (points.length >= 3) {
                    const id = generateId();
                    const area = calculatePolygonArea(points.map(function(p) { return {lat: p[0], lng: p[1]}; }));
                    
                    const asset = {
                      id: id,
                      type: "polygon",
                      label: name,
                      points: points,
                      area: area,
                      color: currentPolygonColor,
                      props: { description: description },
                    };
                    
                    assets.push(asset);
                    addPolygonToMap(asset);
                    addLabelToAsset(asset);
                    importedCount++;
                  }
                }
              }
            }
          }
        }
        
        if (importedCount > 0) {
          renderAssetsList();
          updateStats();
          calculateCableTotals();
          saveData();
          alert("Se importaron " + importedCount + " elementos correctamente.");
        } else {
          alert("No se encontraron elementos válidos para importar en el archivo KML.");
        }
      } catch (error) {
        console.error("Error importando KML:", error);
        alert("Error al importar el archivo KML: " + error.message);
      }
    }

    function importCSV(content) {
      try {
        const lines = content.split('\n');
        let importedCount = 0;
        
        // Saltar la primera línea (encabezados)
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;
          
          // Manejar campos entre comillas que pueden contener comas
          const fields = [];
          let currentField = '';
          let inQuotes = false;
          
          for (let j = 0; j < line.length; j++) {
            const char = line[j];
            
            if (char === '"') {
              inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
              fields.push(currentField);
              currentField = '';
            } else {
              currentField += char;
            }
          }
          fields.push(currentField); // Último campo
          
          if (fields.length >= 5) {
            const id = generateId();
            const type = fields[1] || "poste";
            const label = fields[2] ? fields[2].replace(/^"|"$/g, '') : type + "_" + i;
            const lat = parseFloat(fields[3]);
            const lng = parseFloat(fields[4]);
            
            if (!isNaN(lat) && !isNaN(lng)) {
              // Para polígonos en CSV, necesitamos un formato especial
              if (type === "polygon") {
                // En CSV los polígonos necesitan un formato especial con todos los puntos
                // Por ahora, importamos como punto y el usuario puede convertirlo a polígono
                addAsset(lat, lng, label, "poste"); // Importar como poste por defecto
              } else {
                addAsset(lat, lng, label, type);
              }
              importedCount++;
            }
          }
        }
        
        if (importedCount > 0) {
          alert("Se importaron " + importedCount + " elementos correctamente.");
        } else {
          alert("No se encontraron elementos válidos para importar en el archivo CSV.");
        }
      } catch (error) {
        console.error("Error importando CSV:", error);
        alert("Error al importar el archivo CSV: " + error.message);
      }
    }

    // =========================
    // Clear All Data
    // =========================
    function clearAllData() {
      if (!confirm("¿Estás seguro de que deseas eliminar todos los datos? Esta acción no se puede deshacer.")) {
        return;
      }

      // Eliminar todos los marcadores
      Object.values(markers).forEach(function(marker) { map.removeLayer(marker); });
      markers = {};

      // Eliminar todas las polilíneas
      Object.values(polylines).forEach(function(polyline) { map.removeLayer(polyline); });
      polylines = {};

      // Eliminar todos los polígonos
      Object.values(polygons).forEach(function(polygon) { map.removeLayer(polygon); });
      polygons = {};

      // Eliminar todas las etiquetas
      Object.values(labelLayers).forEach(function(label) { map.removeLayer(label); });
      labelLayers = {};

      // Eliminar etiquetas de distancia
      distanceLabels.forEach(function(label) { map.removeLayer(label); });
      distanceLabels = [];

      // Limpiar arrays temporales
      tempMarkers.forEach(function(m) { map.removeLayer(m); });
      tempPolylines.forEach(function(l) { map.removeLayer(l); });
      tempPolygonMarkers.forEach(function(m) { map.removeLayer(m); });
      tempPolygonLines.forEach(function(l) { map.removeLayer(l); });
      if (tempPolygon) {
        map.removeLayer(tempPolygon);
        tempPolygon = null;
      }
      tempMarkers = [];
      tempPolylines = [];
      tempPolygonMarkers = [];
      tempPolygonLines = [];
      cablePoints = [];
      polygonPoints = [];
      drawingCable = false;
      drawingPolygon = false;
      
      // Limpiar ubicación actual
      clearCurrentLocation();

      // Limpiar datos
      assets = [];
      selectedAssetId = null;

      // Reiniciar contadores
      Object.keys(assetCounters).forEach(function(key) {
        assetCounters[key] = 0;
      });

      // Actualizar UI
      renderAssetsList();
      updateStats();
      calculateCableTotals();
      updateDistanceDisplay(0);
      document.getElementById("segment-distance").textContent = "Último segmento: 0.00 metros";
      document.getElementById("polygon-area").textContent = "Área: 0.00 m²";

      // Limpiar localStorage
      localStorage.removeItem("fibermapper_assets");
      localStorage.removeItem("fibermapper_asset_counters");
      localStorage.removeItem("fibermapper_map_type");

      // Restablecer panel de edición
      document.getElementById("editor-panel").style.display = "none";
      document.getElementById("no-selection-message").style.display = "block";
      
      // Ocultar puntero estático
      document.getElementById("static-crosshair").style.display = "none";
      document.getElementById("add-at-pointer-btn").style.display = "none";
      staticCrosshairVisible = false;
    }

    function getCurrentLocation(highAccuracy) {
      if (!navigator.geolocation) {
        alert("La geolocalización no es compatible con este navegador.");
        return;
      }

      const options = {
        enableHighAccuracy: highAccuracy,
        timeout: 10000,
        maximumAge: 0
      };

      document.getElementById("gps-status").textContent = "Obteniendo ubicación...";

      navigator.geolocation.getCurrentPosition(
        function(position) {
          const lat = position.coords.latitude;
          const lng = position.coords.longitude;
          const accuracy = position.coords.accuracy;

          document.getElementById("gps-status").textContent = 
            "Precisión: ±" + accuracy.toFixed(1) + " metros";

          // Centrar mapa en la ubicación
          map.setView([lat, lng], 18);

          // Agregar marcador temporal
          const marker = L.circleMarker([lat, lng], {
            radius: 8,
            color: "#10b981",
            fillColor: "#10b981",
            fillOpacity: 0.7
          }).addTo(map);

          setTimeout(function() {
            map.removeLayer(marker);
          }, 5000);

          // Confirmar para agregar activo
          if (confirm("¿Agregar activo en esta ubicación? (Precisión: ±" + accuracy.toFixed(1) + "m)")) {
            const type = document.getElementById("gps-type").value;
            const label = document.getElementById("gps-label").value || 
                         type.toUpperCase() + "_GPS_" + new Date().getTime().toString().slice(-4);
            
            document.getElementById("asset-type-selector").value = type;
            
            if (type === "polygon") {
              // Para polígonos, iniciar dibujo
              startPolygonDrawing();
              addPolygonPoint({ lat: lat, lng: lng });
            } else {
              addAsset(lat, lng);
            }
            
            closeGpsModal();
          }
        },
        function(error) {
          let errorMsg = "Error al obtener la ubicación: ";
          switch(error.code) {
            case error.PERMISSION_DENIED:
              errorMsg += "Permiso denegado";
              break;
            case error.POSITION_UNAVAILABLE:
              errorMsg += "Posición no disponible";
              break;
            case error.TIMEOUT:
              errorMsg += "Tiempo de espera agotado";
              break;
            default:
              errorMsg += "Error desconocido";
          }
          document.getElementById("gps-status").textContent = errorMsg;
        },
        options
      );
    }

    function openExportModal() {
      document.getElementById("export-modal").style.display = "flex";
    }

    function closeExportModal() {
      document.getElementById("export-modal").style.display = "none";
      document.getElementById("share-options-container").style.display = "none";
      selectedExportFormat = null;
    }

    function openGpsModal() {
      document.getElementById("gps-modal").style.display = "flex";
    }

    function closeGpsModal() {
      document.getElementById("gps-modal").style.display = "none";
      document.getElementById("gps-status").textContent = "";
    }

    // =========================
    // Inicialización y Event Listeners
    // =========================
    document.addEventListener("DOMContentLoaded", function() {
      console.log("DOM cargado, inicializando aplicación...");
      initMap();
      loadSavedData();

      // Selector de tipo de mapa
      document.getElementById("standard-map-btn").addEventListener("click", function() { switchMapType("standard"); });
      document.getElementById("satellite-map-btn").addEventListener("click", function() { switchMapType("satellite"); });
      document.getElementById("googleearth-map-btn").addEventListener("click", function() { switchMapType("googleearth"); });

      // Selector de tipo de activo - actualizar puntero estático cuando cambie
      document.getElementById("asset-type-selector").addEventListener("change", updateStaticCrosshair);

      // Selector de tipo de cable
      var cableOptions = document.querySelectorAll(".cable-option");
      cableOptions.forEach(function(option) {
        option.addEventListener("click", function() {
          cableOptions.forEach(function(opt) { opt.classList.remove("selected"); });
          this.classList.add("selected");
          currentCableType = this.getAttribute("data-type");
        });
      });

      // Selector de tipo de instalación de cable
      var installationOptions = document.querySelectorAll(".cable-installation-option");
      installationOptions.forEach(function(option) {
        option.addEventListener("click", function() {
          installationOptions.forEach(function(opt) { opt.classList.remove("selected"); });
          this.classList.add("selected");
          currentCableInstallation = this.getAttribute("data-installation");
        });
      });

      // Paleta de colores para polígonos
      var colorOptions = document.querySelectorAll(".color-option");
      colorOptions.forEach(function(option) {
        option.addEventListener("click", function() {
          colorOptions.forEach(function(opt) { opt.classList.remove("selected"); });
          this.classList.add("selected");
          currentPolygonColor = this.getAttribute("data-color");
        });
      });

      // Botón para agregar en posición del puntero
      document.getElementById("add-at-pointer-btn").addEventListener("click", addAssetAtPointer);

      // Botón para expandir/contraer panel lateral
      document.getElementById("sidebar-toggle").addEventListener("click", toggleSidebar);

      // Botones de control del mapa
      document.getElementById("locate-me-btn").addEventListener("click", function() {
        toggleLocationTracking();
      });

      document.getElementById("zoom-in-btn").addEventListener("click", function() {
        map.zoomIn();
      });

      document.getElementById("zoom-out-btn").addEventListener("click", function() {
        map.zoomOut();
      });

      document.getElementById("toggle-labels-btn").addEventListener("click", function() {
        toggleLabels();
      });

      // Búsqueda
      document.getElementById("search-input").addEventListener("input", renderAssetsList);

      // Editor
      document.getElementById("editor-label").addEventListener("change", function() {
        if (selectedAssetId) {
          updateAsset(selectedAssetId, { label: this.value });
        }
      });

      document.getElementById("editor-type").addEventListener("change", function() {
        if (selectedAssetId) {
          updateAsset(selectedAssetId, { type: this.value });
        }
      });

      document.getElementById("editor-lat").addEventListener("change", function() {
        if (selectedAssetId) {
          updateAsset(selectedAssetId, { lat: parseFloat(this.value) });
        }
      });

      document.getElementById("editor-lng").addEventListener("change", function() {
        if (selectedAssetId) {
          updateAsset(selectedAssetId, { lng: parseFloat(this.value) });
        }
      });

      document.getElementById("editor-props").addEventListener("change", function() {
        if (selectedAssetId) {
          try {
            const props = JSON.parse(this.value);
            updateAsset(selectedAssetId, { props: props });
          } catch (e) {
            alert("Error en el formato JSON: " + e.message);
          }
        }
      });

      document.getElementById("delete-asset").addEventListener("click", function() {
        if (selectedAssetId) {
          deleteAsset(selectedAssetId);
        }
      });

      // Agregar foto
      document.getElementById("add-photo-btn").addEventListener("click", function() {
        if (selectedAssetId) {
          openPhotoModal(selectedAssetId);
        }
      });

      // Agregar punto manual con coordenadas
      document.getElementById("add-manual-point").addEventListener("click", function() {
        const lat = parseFloat(document.getElementById("manual-lat").value);
        const lng = parseFloat(document.getElementById("manual-lng").value);
        
        if (isNaN(lat) || isNaN(lng)) {
          alert("Por favor ingresa coordenadas válidas");
          return;
        }
        
        const type = document.getElementById("asset-type-selector").value;
        
        if (type === "polygon") {
          if (!drawingPolygon) {
            startPolygonDrawing();
          }
          addPolygonPoint({ lat: lat, lng: lng });
        } else {
          addAsset(lat, lng);
        }
      });

      // Agregar vértice de polígono manual con coordenadas
      document.getElementById("add-manual-polygon-point").addEventListener("click", function() {
        const lat = parseFloat(document.getElementById("manual-polygon-lat").value);
        const lng = parseFloat(document.getElementById("manual-polygon-lng").value);
        
        if (isNaN(lat) || isNaN(lng)) {
          alert("Por favor ingresa coordenadas válidas");
          return;
        }
        
        if (!drawingPolygon) {
          startPolygonDrawing();
        }
        addPolygonPoint({ lat: lat, lng: lng });
      });

      // Controles de cable
      document.getElementById("undo-cable-point").addEventListener("click", undoLastCablePoint);
      document.getElementById("cancel-cable-drawing").addEventListener("click", cancelCableDrawing);
      document.getElementById("finish-cable-drawing").addEventListener("click", finishCableDrawing);

      // Controles de polígono
      document.getElementById("undo-polygon-point").addEventListener("click", undoLastPolygonPoint);
      document.getElementById("cancel-polygon-drawing").addEventListener("click", cancelPolygonDrawing);
      document.getElementById("finish-polygon-drawing").addEventListener("click", finishPolygonDrawing);

      // Controles de edición de polígonos - CORREGIDOS
      document.getElementById("add-polygon-vertex").addEventListener("click", function() {
        if (editingPolygon) {
          // Cambiar mensaje para indicar modo de agregar vértices
          document.getElementById("polygon-edit-status").textContent = 
            "Haz clic en cualquier segmento del polígono para agregar un vértice";
        }
      });
      
      document.getElementById("cancel-polygon-edit").addEventListener("click", cancelPolygonEdit);
      document.getElementById("save-polygon-edit").addEventListener("click", savePolygonEdit);

      // Limpiar pantalla
      document.getElementById("clear-screen").addEventListener("click", clearAllData);
      document.getElementById("clear-sidebar-btn").addEventListener("click", clearAllData);

      // Exportar/Importar
      document.getElementById("export-data").addEventListener("click", openExportModal);
      document.getElementById("close-export").addEventListener("click", closeExportModal);

      var exportOptions = document.querySelectorAll(".export-option");
      exportOptions.forEach(function(option) {
        option.addEventListener("click", function() {
          selectedExportFormat = this.getAttribute("data-format");
          document.getElementById("share-options-container").style.display = "block";
        });
      });

      var shareOptions = document.querySelectorAll(".share-option");
      shareOptions.forEach(function(option) {
        option.addEventListener("click", function() {
          const action = this.getAttribute("data-action");
          if (action === "save" && selectedExportFormat) {
            exportData(selectedExportFormat);
            closeExportModal();
          } else if (action === "whatsapp" && selectedExportFormat) {
            shareViaWhatsApp(selectedExportFormat);
            closeExportModal();
          } else {
            alert("Función de compartir no implementada aún");
          }
        });
      });

      document.getElementById("import-data").addEventListener("change", function(e) {
        if (this.files.length > 0) {
          const file = this.files[0];
          const reader = new FileReader();
          reader.onload = function(e) {
            const content = e.target.result;
            if (file.name.endsWith('.csv')) {
              importCSV(content);
            } else if (file.name.endsWith('.kml')) {
              importKML(content);
            }
          };
          reader.readAsText(file);
          this.value = ""; // Reset input
        }
      });

      // GPS
      document.getElementById("add-gps-btn").addEventListener("click", openGpsModal);
      document.getElementById("gps-cancel").addEventListener("click", closeGpsModal);
      document.getElementById("gps-confirm").addEventListener("click", function() {
        const highAccuracy = document.getElementById("gps-accuracy").value === "true";
        getCurrentLocation(highAccuracy);
      });

      // Photo Modal
      document.getElementById("camera-input").addEventListener("change", function(e) {
        handlePhotoUpload(e, true);
      });
      
      document.getElementById("gallery-input").addEventListener("change", function(e) {
        handlePhotoUpload(e, false);
      });
      
      document.getElementById("photo-cancel").addEventListener("click", closePhotoModal);
      document.getElementById("photo-confirm").addEventListener("click", savePhoto);

      // Toggle sidebar (hamburger en móvil)
      document.getElementById("toggle-sidebar").addEventListener("click", function() {
        toggleSidebar();
      });

      // Inicializar estadísticas
      updateStats();
      calculateCableTotals();
      
      // Inicializar puntero estático
      updateStaticCrosshair();
      
      // Inicializar controles de visibilidad
      updateVisibilityControls();
      
      console.log("Aplicación inicializada correctamente");
    });
  </script>
</body>
</html>











